<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0" />
	<title>Parcel Placement and Warehouse Management</title>
	<link rel="stylesheet" href="main.css" />

</head>

<body>
	<div id="sidebar">
		<h3>Warehouse Dimensions</h3>
		<label for="width">Width:</label>
		<input type="number" id="width" value="750" />
		<br />
		<label for="length">Length:</label>
		<input type="number" id="length" value="650" />
		<br />
		<label for="height">Height:</label>
		<input type="number" id="height" value="450" />
		<br />
		<label for="weight-limit">Weight Limit:</label>
		<input type="number" id="weight-limit" value="1000" />
		<br />
		<button id="apply">Apply</button>
		<br />
		<label  id="weightLimitLabel">Weight</label>
		<br />
		<h4>Boxes</h4>
		<div id="boxList">
			<ul id="boxListItems"></ul>
		</div>
		<button id="addPackageButton">Add Package</button>
	</div>

	<div id="contextMenu">
		<button id="rotateButton">Rotate 90 degrees</button>
		<button id="editButton">Edit</button>
		<button id="copyButton">Copy</button>
		<button id="deleteButton">Delete</button>
	</div>

	<div id="modal">
		<div id="modal-content">
			<span class="close">&times;</span>
			<h3>Add New Package</h3>

			<div class="modal-row">
				<label for="modal-name">Name:</label>
				<input type="text" id="modal-name" placeholder="Enter package name" required />
			</div>

			<div class="modal-row">
				<label for="modal-color">Color:</label>
				<input type="text" id="modal-color" placeholder="Enter package color" required />
			</div>

			<div class="modal-row">
				<label for="modal-width">Width:</label>
				<input type="number" id="modal-width" placeholder="Enter package width" required />
			</div>

			<div class="modal-row">
				<label for="modal-length">Length:</label>
				<input type="number" id="modal-length" placeholder="Enter package length" required />
			</div>

			<div class="modal-row">
				<label for="modal-height">Height:</label>
				<input type="number" id="modal-height" placeholder="Enter package height" required />
			</div>

			<div class="modal-row">
				<label for="modal-weight">Weight:</label>
				<input type="number" id="modal-weight" placeholder="Enter package weight" required />
			</div>

			<div class="modal-row">
				<label for="modal-note">Note:</label>
				<input type="text" id="modal-note" placeholder="Enter package note" />
			</div>

			<div class="modal-row">
				<label for="modal-stack">Can stack?</label>
				<input type="checkbox" id="modal-stack" />
			</div>

			<div class="modal-row">
				<button id="savePackageButton">Submit Package</button>
			</div>
		</div>
	</div>
	weightLimitNotification
	<div id="weightLimitNotification"
		style="display:none; background-color: #f44336; color: white; padding: 15px; position: fixed; top: 20px; left: 50%; transform: translateX(-50%); z-index: 1000;">
		Weight Limit Exceeded.
	</div>
	<div id="collidingObjectNotification"
		style="display:none; background-color: #f44336; color: white; padding: 15px; position: fixed; top: 20px; left: 50%; transform: translateX(-50%); z-index: 1000;">
		Can Not Edit A Colliding Package.
	</div>
	<div id="notification"
		style="display:none; background-color: #f44336; color: white; padding: 15px; position: fixed; top: 20px; left: 50%; transform: translateX(-50%); z-index: 1000;">
		This package cannot be placed on top of a non-stackable package.
	</div>

	<div id="notificationInvalidPlace"
		style="display:none; background-color: #f44336; color: white; padding: 15px; position: fixed; top: 20px; left: 50%; transform: translateX(-50%); z-index: 1000;">
		Package can not be placed here.
	</div>

	<div id="weightNotification"
		style="display:none; background-color: #f44336; color: white; padding: 15px; position: fixed; top: 20px; left: 50%; transform: translateX(-50%); z-index: 1000;">
		This package cannot be placed on top of a lighter package.
	</div>

	<div id="manyCollisionsNotification"
		style="display:none; background-color: #f44336; color: white; padding: 15px; position: fixed; top: 20px; left: 50%; transform: translateX(-50%); z-index: 1000;">
		Many collisions to handle.
	</div>

	<div id="scaleNotification"
		style="display:none; background-color: #f44336; color: white; padding: 15px; position: fixed; top: 20px; left: 50%; transform: translateX(-50%); z-index: 1000;">
		This package cannot be placed on top of a smaller package.
	</div>

	<div id="stackedNotification"
		style="display:none; background-color: #f44336; color: white; padding: 15px; position: fixed; top: 20px; left: 50%; transform: translateX(-50%); z-index: 1000;">
		Can not move understacked package.
	</div>

	<div id="editNotification"
		style="display:none; background-color: #f44336; color: white; padding: 15px; position: fixed; top: 20px; left: 50%; transform: translateX(-50%); z-index: 1000;">
		Can edit while moving a package.
	</div>

	<div id="warningMessage"
		style="display:none; position: fixed; top: 10px; left: 50%; transform: translateX(-50%); padding: 10px; background-color: yellow; color: red; font-size: 16px; border-radius: 5px;">
		Warning: The package is outside the warehouse!
	</div>

	<script type="importmap">
        {
            "imports": {
                "three": "./build/three.module.js",
                "three/addons/": "./jsm/"
            }
        }
    </script>

	<script type="module">
		import * as THREE from "three";
		import { OrbitControls } from "./jsm/controls/OrbitControls.js";

		let camera, scene, renderer;
		let raycaster, isShiftDown = false;
		let pointer = new THREE.Vector2();
		let rollOverMesh;
		let cubeGeo, cubeMaterial;
		let cursorOffset = new THREE.Vector3(); 

		const objects = [];
		let totalWeight = 0;
		let selectedPackage = null;
		let edittingPackage = null;
		let contextMenuVisible = false;
		let isDragging = false;
		let cameraControls;
		let plane;
		let warehouseGroup;
		let isColliding = false;
		let stickToCursor = false; 
		let collidingObject = null;
		let rightClickedObject = null;

		let selectedPackageEdges = null; 

		const inBoundSnapMargin = 10
		let stackCounter = 0
		let canStack = true;
		let canPlace = false
		let pressStartTime; // To store the timestamp when the pointer is pressed
		const LONG_PRESS_THRESHOLD = 500; // Threshold in milliseconds for a long press

		const mousePositionInWorld = new THREE.Vector3(); // For storing the result

		const targetY = 0; //I prefer using constants instead of numbers

		const redColor = 0xFF0000
		const greenColor = 0x00FF00
		const whiteColor = 0xFFFFFF
		const blackColor = 0x000000

		let isInEditor = true

		let warehouseDimensions = {
			width: 500,
			length: 500,
			height: 350,
			weightLimit: 1000,
		};

		const packages = [];

		init();
		render();

		function init() {
			camera = new THREE.PerspectiveCamera(20, window.innerWidth / window.innerHeight, 1, 10000);
			camera.position.set(0, 500, 1500);
			camera.lookAt(0, 0, 0);

			scene = new THREE.Scene();
			scene.background = new THREE.Color(0x333333);

			const gridHelper = new THREE.GridHelper(1500, 15);
			gridHelper.position.y = 0;
			scene.add(gridHelper);

			const rollOverGeometry = new THREE.BoxGeometry(100, 100, 100);
			const rollOverMaterial = new THREE.MeshBasicMaterial({
				color: 0x999999,
				wireframe: true,
				transparent: true,
				opacity: 0
			});
			rollOverMesh = new THREE.Mesh(rollOverGeometry, rollOverMaterial);
			scene.add(rollOverMesh);  // Add rollOverMesh to the scene


			raycaster = new THREE.Raycaster();
			pointer = new THREE.Vector2();
			createWarehouseSurface();


			const ambientLight = new THREE.AmbientLight(0x606060, 3);
			scene.add(ambientLight);

			const directionalLight = new THREE.DirectionalLight(0xffffff, 3);
			directionalLight.position.set(1, 0.75, 0.5).normalize();
			scene.add(directionalLight);

			renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);
			document.body.appendChild(renderer.domElement);

			cameraControls = new OrbitControls(camera, renderer.domElement);
			cameraControls.enableDamping = true;
			cameraControls.dampingFactor = 0.25;
			cameraControls.autoRotation = true;
			cameraControls.screenSpacePanning = false;

			document.addEventListener("pointermove", onPointerMove);
			document.addEventListener("pointerdown", onPointerDown);
			document.addEventListener("pointerup", onPointerUp);
			document.addEventListener("keydown", onDocumentKeyDown);
			document.addEventListener("keyup", onDocumentKeyUp);
			window.addEventListener("resize", onWindowResize);

			document.addEventListener("contextmenu", onRightClick);
			document.addEventListener("click", onLeftClick);

			document.getElementById("apply").addEventListener("click", function () {
				warehouseDimensions.width = parseFloat(document.getElementById("width").value);
				warehouseDimensions.length = parseFloat(document.getElementById("length").value);
				warehouseDimensions.height = parseFloat(document.getElementById("height").value);
				warehouseDimensions.weightLimit = parseFloat(document.getElementById("weight-limit").value);
				document.getElementById("weightLimitLabel").innerHTML = "Weight: "+totalWeight+"/"+warehouseDimensions.weightLimit+" KG"
				calculateTotalWeight();
				if (totalWeight>warehouseDimensions.weightLimit){
					showNotification("weightLimitNotification");
				};
				createWarehouseSurface();
			});
			document.getElementById("weightLimitLabel").style.color = "green"
			document.getElementById("weightLimitLabel").innerHTML= "Weight: "+totalWeight+"/"+warehouseDimensions.weightLimit+" KG"

			document.getElementById("rotateButton").addEventListener("click", rotateParcel);
			document.getElementById("editButton").addEventListener("click", editPackage);
			document.getElementById("copyButton").addEventListener("click", copyParcel);
			document.getElementById("deleteButton").addEventListener("click", deleteParcel);


			document.querySelector(".close").addEventListener("click", closeModal);
		}

		let isEditing = false;

		document.getElementById("addPackageButton").addEventListener("click", openModal);

		document.getElementById("savePackageButton").addEventListener("click", function () {
			if (isEditing) {
				saveEditedPackage();
			} else {
				addPackage();
			}
		});

		function calculateTotalWeight() {
			totalWeight = packages.reduce((total, packageData) => total + packageData.weight, 0);
			document.getElementById("weightLimitLabel").innerHTML= "Weight: "+totalWeight+"/"+warehouseDimensions.weightLimit+" KG"
			if (totalWeight>warehouseDimensions.weightLimit){
				document.getElementById("weightLimitLabel").style.color = "red"
			}else if (totalWeight==warehouseDimensions.weightLimit){
				document.getElementById("weightLimitLabel").style.color = "black"
			}else{
				document.getElementById("weightLimitLabel").style.color = "green"
			}
			return totalWeight;
		}

		function editPackage(index = null) {
			isInEditor = false;
			document.getElementById("modal-width").disabled = false;
			document.getElementById("modal-length").disabled = false;
			document.getElementById("modal-height").disabled = false;
			document.getElementById("modal-stack").disabled = false;
			if (index !== undefined && index !== null && index >= 0) {
				const pkg = packages[index];
				const mesh = objects[index];

				if (!pkg || !mesh) {
					alert("Package or mesh not found.");
					isInEditor = true;
					return;
				}
				let isMeshColliding = checkCollisions(mesh)

				edittingPackage = mesh;

				document.getElementById("modal-name").value = pkg.name || "";
				document.getElementById("modal-width").value = pkg.width || 100;
				document.getElementById("modal-length").value = pkg.length || 100;
				document.getElementById("modal-height").value = pkg.height || 100;
				document.getElementById("modal-color").value = pkg.color || white;
				document.getElementById("modal-weight").value = pkg.weight || 100;
				document.getElementById("modal-note").value = pkg.note || "";
				document.getElementById("modal-stack").checked = pkg.canStack || false;
				if (isMeshColliding){
					document.getElementById("modal-width").disabled = true;
					document.getElementById("modal-length").disabled = true;
					document.getElementById("modal-height").disabled = true;
				}else{
					document.getElementById("modal-width").disabled = false;
					document.getElementById("modal-length").disabled = false;
					document.getElementById("modal-height").disabled = false;
				}

				if(mesh.userData.packageData.topPackage != null){
					document.getElementById("modal-stack").disabled = true;
				}else{
					document.getElementById("modal-stack").disabled = false;
				}

				document.getElementById("modal").style.display = "flex";

				isEditing = true;

			} else if (edittingPackage) {

				const packageData = edittingPackage.userData.packageData;

				if (!packageData) {
					alert("Package data is missing.");
					isInEditor = true;
					return;
				}
				let isMeshColliding = checkCollisions(edittingPackage)

				document.getElementById("modal-name").value = packageData.name || "";
				document.getElementById("modal-width").value = packageData.width;
				document.getElementById("modal-length").value = packageData.length;
				document.getElementById("modal-height").value = packageData.height;
				document.getElementById("modal-color").value = packageData.color;
				document.getElementById("modal-weight").value = packageData.weight;
				document.getElementById("modal-note").value = packageData.note || "";
				document.getElementById("modal-stack").checked = packageData.canStack || false;
				if (isMeshColliding){
					document.getElementById("modal-width").disabled = true;
					document.getElementById("modal-length").disabled = true;
					document.getElementById("modal-height").disabled = true;
				}else{
					document.getElementById("modal-width").disabled = false;
					document.getElementById("modal-length").disabled = false;
					document.getElementById("modal-height").disabled = false;
				}

				if(packageData.topPackage != null){
					document.getElementById("modal-stack").disabled = true;
				}else{
					document.getElementById("modal-stack").disabled = false;
				}

				document.getElementById("modal").style.display = "flex";

				isEditing = true;
			} else if(rightClickedObject){
				edittingPackage = rightClickedObject
				const packageData = edittingPackage.userData.packageData;
				let isMeshColliding = checkCollisions(rightClickedObject)

				if (!packageData) {
					alert("Package data is missing.");
					isInEditor = true;
					return;
				}

				document.getElementById("modal-name").value = packageData.name || "";
				document.getElementById("modal-width").value = packageData.width;
				document.getElementById("modal-length").value = packageData.length;
				document.getElementById("modal-height").value = packageData.height;
				document.getElementById("modal-color").value = packageData.color;
				document.getElementById("modal-weight").value = packageData.weight;
				document.getElementById("modal-note").value = packageData.note || "";
				document.getElementById("modal-stack").checked = packageData.canStack || false;
				if (isMeshColliding){
					document.getElementById("modal-width").disabled = true;
					document.getElementById("modal-length").disabled = true;
					document.getElementById("modal-height").disabled = true;
				}else{
					document.getElementById("modal-width").disabled = false;
					document.getElementById("modal-length").disabled = false;
					document.getElementById("modal-height").disabled = false;
				}

				if(packageData.topPackage != null){
					document.getElementById("modal-stack").disabled = true;
				}else{
					document.getElementById("modal-stack").disabled = false;
				}

				document.getElementById("modal").style.display = "flex";

				isEditing = true;
			}else{
				isInEditor = true;
				alert("No package selected.");
			}
		}

		function saveEditedPackage() {
			if (!edittingPackage) {
				alert("No package selected.");
				clearEditPackageData();
				return;
			}

			const packageData = edittingPackage.userData.packageData;

			if (!packageData) {
				alert("Package data is missing.");
				clearEditPackageData();
				return;
			}

			const updatedName = document.getElementById("modal-name").value;
			const updatedWidth = parseFloat(document.getElementById("modal-width").value || 100);
			const updatedLength = parseFloat(document.getElementById("modal-length").value || 100);
			const updatedHeight = parseFloat(document.getElementById("modal-height").value || 100);
			const updatedColor = document.getElementById("modal-color").value || "white";
			const updatedWeight = parseFloat(document.getElementById("modal-weight").value || 100);
			const updatedNote = document.getElementById("modal-note").value;
			const updatedCanStack = document.getElementById("modal-stack").checked;

			packageData.name = updatedName;
			packageData.width = updatedWidth;
			packageData.length = updatedLength;
			packageData.height = updatedHeight;
			packageData.color = updatedColor;
			packageData.weight = updatedWeight;
			packageData.note = updatedNote;
			packageData.canStack = updatedCanStack;

			edittingPackage.geometry.dispose();
			edittingPackage.material.dispose();
			edittingPackage.geometry = new THREE.BoxGeometry(updatedWidth, updatedHeight, updatedLength);
			edittingPackage.material = new THREE.MeshLambertMaterial({ color: new THREE.Color(updatedColor) });
			if(packageData.isRotated){
				edittingPackage.position.y = packageData.width/2
			}else{
				edittingPackage.position.y = packageData.height/2
			}
			document.getElementById("modal").style.display = "none";

			updateBoxList();

			calculateTotalWeight();
			if (totalWeight>warehouseDimensions.weightLimit){
				showNotification("weightLimitNotification");
			};

			render();

			clearEditPackageData();
		}

		function clearEditPackageData(){
			rightClickedObject = null;
			edittingPackage = null;
			isEditing = false;
			isInEditor = true;
			rightClickedObject = null;
		}

		function openModal() {
			document.getElementById("modal-width").disabled = false;
			document.getElementById("modal-length").disabled = false;
			document.getElementById("modal-height").disabled = false;
			document.getElementById("modal-stack").disabled = false;
			document.getElementById("modal").style.display = "flex";
			isEditing = false;
			isInEditor = false;
		}

		const margin = 5;

		let lastPosition = { x: -warehouseDimensions.width / 2 - margin, y: 45, z: -warehouseDimensions.length / 2 - margin };  // Starting point for placing packages


		function addPackage() {
			const name = document.getElementById("modal-name").value || "";
			const color = document.getElementById("modal-color").value || "red";
			const width = parseFloat(document.getElementById("modal-width").value || 100);
			const length = parseFloat(document.getElementById("modal-length").value || 100);
			const height = parseFloat(document.getElementById("modal-height").value || 100);
			const weight = parseFloat(document.getElementById("modal-weight").value || 100);
			const note = document.getElementById("modal-note").value;
			const canStack = document.getElementById("modal-stack").checked;
			const topPackage = null;
			const underPackage = null;
			const leftPackage = null;
			const rightPackage = null;
			const frontPackage = null;
			const backPackage = null;
			const isRotated = false;

			const newPackage = {
				name,
				color,
				width,
				length,
				height,
				weight,
				note,
				canStack,
				topPackage,
				underPackage,
				leftPackage,
				rightPackage,
				frontPackage,
				backPackage,
				isRotated,
				type: 'parcel',
			};

			const packageMesh = new THREE.Mesh(
				new THREE.BoxGeometry(width, height, length),
				new THREE.MeshLambertMaterial({ color: new THREE.Color(color) })
			);

			packageMesh.userData = { type: 'parcel', packageData: newPackage };

			for (const obj of objects) {
				if (obj !== packageMesh && obj.userData.type === 'parcel' && !obj.userData.packageData.canStack) {
					const otherPackage = obj;
					if (checkCollision(packageMesh, otherPackage).originalCollision) {
						const notification = document.getElementById('notification');
						notification.style.display = 'block';  
						setTimeout(() => {
							notification.style.display = 'none';  // Hide after 3 seconds
							isInEditor = true
						}, 3000);
						return;
					}
				}
			}


			const position = {
				x: lastPosition.x + width + 5, // Place the new package slightly to the right of the last one
				y: height/2, // Keep the height constant
				z: lastPosition.z, // Keep the z-position constant (or change if you want to move it in the z-direction)
			};
			let newX = lastPosition.x + width + 5;
			let newZ = lastPosition.z;

			newX = Math.max(Math.min(newX, warehouseDimensions.width / 2 - width / 2), -warehouseDimensions.width / 2 + width / 2);

			newZ = Math.max(Math.min(newZ, warehouseDimensions.length / 2 - length / 2), -warehouseDimensions.length / 2 + length / 2);

			packageMesh.position.set(newX, position.y, newZ);

			scene.add(packageMesh);
			objects.push(packageMesh);
			packages.push(newPackage);

			lastPosition.x = position.x + width;

			updateBoxList();
			calculateTotalWeight();
			if (totalWeight > warehouseDimensions.weightLimit){
				showNotification("weightLimitNotification");
			};
			render();
			closeModal();
		}

		function checkCollision(package1, package2, collisionMargin = -20) {
			// Create bounding boxes for both packages
			const box1 = new THREE.Box3().setFromObject(package1);
			const box2 = new THREE.Box3().setFromObject(package2);

			// Apply the margin by adjusting the min and max coordinates
			const box1WithMargin = new THREE.Box3(
				box1.min.clone().addScalar(-collisionMargin),
				box1.max.clone().addScalar(collisionMargin)
			);

			const box2WithMargin = new THREE.Box3(
				box2.min.clone().addScalar(-collisionMargin),
				box2.max.clone().addScalar(collisionMargin)
			);

			// Perform intersection checks
			const originalCollision = box1.intersectsBox(box2);
			const marginCollision = box1WithMargin.intersectsBox(box2WithMargin);

			// Return both results
			return {
				originalCollision,
				marginCollision,
			};
		}

		function createWarehouseSurface() {
			if (warehouseGroup) {
				scene.remove(warehouseGroup);
			}

			const blackPlaneGeometry = new THREE.PlaneGeometry(warehouseDimensions.width, warehouseDimensions.length);
			const blackPlaneMaterial = new THREE.MeshBasicMaterial({ color: 0x1F4529 });
			const blackPlane = new THREE.Mesh(blackPlaneGeometry, blackPlaneMaterial);
			blackPlane.rotation.x = -Math.PI / 2;
			blackPlane.position.y = 0;

			const geometry = new THREE.BoxGeometry(
				warehouseDimensions.width,
				warehouseDimensions.height,
				warehouseDimensions.length
			);
			const surfaceMaterial = new THREE.MeshBasicMaterial({
				color: 0xffffff,
				transparent: true,
				opacity: 0,
			});
			const wireframeMaterial = new THREE.LineBasicMaterial({
				color: 0x000000,
				linewidth: 3
			});

			plane = new THREE.Mesh(geometry, surfaceMaterial);
			plane.position.set(0, warehouseDimensions.height, 0);

			const wireframeEdges = new THREE.EdgesGeometry(geometry);
			const wireframe = new THREE.LineSegments(wireframeEdges, wireframeMaterial);

			wireframe.position.set(0, warehouseDimensions.height / 2, 0); // Adjust the Y position, for example, move it slightly above

			warehouseGroup = new THREE.Group();
			warehouseGroup.add(blackPlane); // Add black plane beneath the grid
			warehouseGroup.add(plane);
			warehouseGroup.add(wireframe);

			scene.add(warehouseGroup);
			/**objects.push(plane);  // Add to objects array for raycasting purposes**/
			/**I think the plane should not be added to the same array of the clickable objects**/
		}

		function closeModal() {
			document.getElementById("modal").style.display = "none";
			clearEditPackageData()
		}

		let lastValidPosition = new THREE.Vector3();

		function getMousePosition(event) {
			// Convert screen coordinates to normalized device coordinates (NDC)
			pointer.set(
				(event.clientX / window.innerWidth) * 2 - 1, // X: -1 to 1
				-(event.clientY / window.innerHeight) * 2 + 1 // Y: -1 to 1
			);

			// Unproject the NDC into world space
			mousePositionInWorld.set(pointer.x, pointer.y, 0);
			mousePositionInWorld.unproject(camera);

			// Calculate direction from camera to mouse
			const cameraToWorld = mousePositionInWorld.clone().sub(camera.position).normalize();

			// Adjust Y to match the target plane (e.g., ground or a specific Y)
			const distance = (targetY - camera.position.y) / cameraToWorld.y;
			mousePositionInWorld.copy(camera.position).add(cameraToWorld.multiplyScalar(distance));

			return mousePositionInWorld;
		}


		function onPointerMove(event) {
			setPointer()
			if (stickToCursor && selectedPackage) {
				if(!isInEditor){
					stickToCursor = false
					selectedPackage = false
				}else{
					handlePackagePosition()
				}
				if (!isBoxInsideWarehouse()) {
					changeEdgeColor(redColor)
					document.getElementById("warningMessage").style.display = "block";  // Show warning message
				} else {
					changeEdgeColor(greenColor)
					document.getElementById("warningMessage").style.display = "none";  // Hide warning message
				}
				console.log("stack count is ",stackCounter)
				if (handleMovementCollisions() == 0 ){
					handleNoCollisionLogic()
				}else{
					isColliding = true
					handleStackLogic()
				}
			}
			render();
		}

		function setPointer(){
			pointer.set(
				(event.clientX / window.innerWidth) * 2 - 1,
				-(event.clientY / window.innerHeight) * 2 + 1
			);
			raycaster.setFromCamera(pointer, camera);
		}

		function handlePackagePosition(){
			const mousePos = getMousePosition(event);
			if (mousePos) {
				if (!adjustPackagePositionToWareHouseBounds(mousePos)){
					selectedPackage.position.x = mousePos.x;
					selectedPackage.position.z = mousePos.z;
				}
			}
		}

		function adjustPackagePositionToWareHouseBounds(mousePos){
			const boxHalfWidth = getPackageWidth(selectedPackage) / 2;
			const boxHalfLength = selectedPackage.geometry.parameters.depth / 2; // For length (z-axis)

			const minX = mousePos.x - boxHalfWidth;
			const maxX = mousePos.x + boxHalfWidth;
			const minZ = mousePos.z - boxHalfLength;
			const maxZ = mousePos.z + boxHalfLength;

			const warehouseMinX = -warehouseDimensions.width / 2;
			const warehouseMaxX = warehouseDimensions.width / 2;
			const warehouseMinZ = -warehouseDimensions.length / 2;
			const warehouseMaxZ = warehouseDimensions.length / 2;

			const isCloseMinX = Math.abs(warehouseMinX-minX)
			const isCloseMaxX = Math.abs(warehouseMaxX-maxX)
			const isCloseMinZ = Math.abs(warehouseMinZ-minZ)
			const isCloseMaxZ = Math.abs(warehouseMaxZ-maxZ)
			let isInBound = false
			if (isCloseMinX<inBoundSnapMargin){
				if (isCloseMaxX<inBoundSnapMargin && isCloseMaxX<isCloseMinX){
					selectedPackage.position.x = warehouseMaxX - boxHalfWidth
					isInBound = true
				}else{
					selectedPackage.position.x = warehouseMinX + boxHalfWidth
					isInBound = true
				}
			}else if(isCloseMaxX<inBoundSnapMargin){
				selectedPackage.position.x = warehouseMaxX - boxHalfWidth
				isInBound = true
			}else{
				selectedPackage.position.x = mousePos.x;
			}
			if (isCloseMinZ<inBoundSnapMargin){
				if (isCloseMaxZ<inBoundSnapMargin && isCloseMaxZ<isCloseMinZ){
					selectedPackage.position.z = warehouseMaxZ - boxHalfLength
					isInBound = true
				}else{
					selectedPackage.position.z = warehouseMinZ + boxHalfLength
					isInBound = true
				}
			}else if(isCloseMaxZ<inBoundSnapMargin){
				selectedPackage.position.z = warehouseMaxZ - boxHalfLength
				isInBound = true
			}else{
				selectedPackage.position.z = mousePos.z;
			}

			return isInBound;
		}

		function handleMovementCollisions(){
			let collisionCount = 0
			for (const obj of objects) {
				if (obj !== selectedPackage && obj.userData.type === 'parcel') {
					const otherPackage = obj;
					const collisions = checkCollision(selectedPackage, otherPackage)
					const areColliding = collisions.originalCollision
					const areMarginColliding = collisions.marginCollision
					if (areColliding && obj.userData) {
						collisionCount = collisionCount + 1
						collidingObject = obj
						if (!areMarginColliding){
							if(stackCounter === 0){
								console.log("outside margin")
								changeEdgeColor(greenColor)
								canStack = false;
								canPlace = true;
								selectedPackage.position.y = getPackageHeight(selectedPackage);
							}
						}else{
							console.log("inside margin")
							stackCounter = stackCounter + 1
							const otherPackageTop = otherPackage.position.y + getPackageHeight(otherPackage);
							selectedPackage.position.y = otherPackageTop + getPackageHeight(selectedPackage);
						}
					}
				}
			}
			return collisionCount
		}

		function handleNoCollisionLogic(){
			stackCounter = 0
			console.log("collision count is 0")
			isColliding = false
			canPlace = true;
			if (selectedPackage){
				selectedPackage.position.y = getPackageHeight(selectedPackage)
			}
		}

		function handleStackLogic(){
			if(stackCounter !=0 && collidingObject){
				if (collidingObject.userData.packageData.canStack) {
					changeEdgeColor(greenColor)
					canStack = true;
					canPlace = true;
					console.log("can stack")
				}else {
					changeEdgeColor(redColor);
					canStack = false;
					canPlace = false;
					const notification = document.getElementById('notification');
					notification.style.display = 'block';
					setTimeout(() => {
						notification.style.display = 'none';
					}, 1000);
					console.log("can not stack")
				}
			}
		}

		function getPackageHeight(mPackage){
			if(mPackage !=null){
				if (mPackage.userData.packageData.isRotated){
					return mPackage.geometry.parameters.width/2
				}else{
					return mPackage.geometry.parameters.height/2
				}
			}else{
				return targetY;
			}
		}

		function getPackageWidth(mPackage){
			if(mPackage !=null){
				if (mPackage.userData.packageData.isRotated){
					return mPackage.geometry.parameters.height
				}else{
					return mPackage.geometry.parameters.width
				}
			}else{
				return targetY;
			}
		}

		/**
		 * Click Listeners Start
		 * **/
		function onPointerDown(event){
			if (event.button === 0) {
				if (contextMenuVisible) return;
				pressStartTime = Date.now();
			}
		}

		function onPointerUp(event) {
			if (event.button === 0) {
				console.log("Left click released.");
				if(!isInEditor){//This disables any interraction if user is editting or adding a package
					stickToCursor = false
					selectedPackage = false
					return;
				}
				/**WE NEED TO MAKE SURE THAT CAMERA MOVEMENT AND 
				 * DRAGGING AN OBJECT DO NOT HAPPEN IN THE SAME TIME
				 * THE BEST WAY IS TO TRIGGER BOTH OF THEN IN POINTER UP**/
				const pressDuration = Date.now() - pressStartTime;//This determines of the user clicked on an object
				if(pressDuration<LONG_PRESS_THRESHOLD){
					packageClicked()
				}else if (isDragging) {
					stopDragging()
				}
			}
		}

		function onLeftClick(event) {
			const menu = document.getElementById("contextMenu");
			menu.style.display = "none";
			contextMenuVisible = false;

			if (isDragging) {
				isDragging = false;
				cameraControls.enabled = false;
				document.getElementById("warningMessage").style.display = "none";
			}

			render();
		}

		function onRightClick(event) {
			if (!stickToCursor){
				event.preventDefault();
				const mousePos = getMousePosition(event);
				EditObject()
				const menu = document.getElementById("contextMenu");
				const { clientX: mouseX, clientY: mouseY } = event;

				if (!rightClickedObject.userData.type === 'parcel') return;

				contextMenuVisible = true;
				menu.style.display = "block";
				menu.style.left = `${mouseX}px`;
				menu.style.top = `${mouseY}px`;
			}else{
				const notification = document.getElementById('editNotification');
				notification.style.display = 'block';  
				setTimeout(() => {
					notification.style.display = 'none';  // Hide after 2 seconds
					isInEditor = true
				}, 2000);
			}
		}

		/**
		 * Click Listeners End
		 * **/

		function packageClicked(){
			const mousePos = getMousePosition(event);
			if (mousePos) {
				if (stickToCursor){
					dropObject()
				}else{
					pickObject(mousePos.x,mousePos.z,targetY)
				}
			}
		}

		function stopDragging(){
			isDragging = false;
			cameraControls.enabled = true;
			document.getElementById("warningMessage").style.display = "none";
		}

		function dropObject(){
			/** Set off outlines here **/
			if(canPlace){
				if(isColliding && collidingObject){
					if (canStack) {
						console.log("dropped object can stack")
						/** which means the object is being stacked **/
						if (checkPackageBiggerThanPackage(selectedPackage,collidingObject)){
							showNotification('scaleNotification',2000);
						}else if (checkPackageHeavierThanPackage(selectedPackage,collidingObject)){
							showNotification('weightNotification',2000);
						}else{
							stackObjectOnTop();
						}
					}else {	
						snapPackageToCollider();
					}
				}else{
					if(isColliding){
						showNotification('notification',2000);
					}else{
						freeDropObject()
					}
				}
			}
		}

		function isBoxInsideWarehouse() {
			if(!selectedPackage){
				return false;
			}
			// Get the dimensions of the box (package)
			const boxHalfWidth = getPackageWidth(selectedPackage) / 2;
			const boxHalfLength = selectedPackage.geometry.parameters.depth / 2; // For length (z-axis)

			// Calculate the outer edges of the box
			const minX = selectedPackage.position.x - boxHalfWidth;
			const maxX = selectedPackage.position.x + boxHalfWidth;
			const minZ = selectedPackage.position.z - boxHalfLength;
			const maxZ = selectedPackage.position.z + boxHalfLength;

			// Warehouse boundaries with margin
			const warehouseMinX = -warehouseDimensions.width / 2;
			const warehouseMaxX = warehouseDimensions.width / 2;
			const warehouseMinZ = -warehouseDimensions.length / 2;
			const warehouseMaxZ = warehouseDimensions.length / 2;

			// Check if the box is entirely inside the warehouse
			const isInside =
				minX >= warehouseMinX &&
				maxX <= warehouseMaxX &&
				minZ >= warehouseMinZ &&
				maxZ <= warehouseMaxZ;

			return isInside;
		}

		function checkPackageBiggerThanPackage(package1,package2){
			if (!(package1 && package2)){
				return false;
			}else{
				const widthComparison = getPackageWidth(package1) > getPackageWidth(package2)
				const lengthComparison = package1.userData.packageData.length > package2.userData.packageData.length
				return widthComparison || lengthComparison;
			}
		}

		function checkPackageHeavierThanPackage(package1,package2){
			if (package1 && package2){
				return package1.userData.packageData.weight > package2.userData.packageData.weight;
			}else{
				return false;
			}
		}

		function showNotification(notificationName, notificationDuration = 2000){
			const notification = document.getElementById(notificationName);
			notification.style.display = 'block';  
			setTimeout(() => {
				notification.style.display = 'none';
				isInEditor = true
			}, notificationDuration);
		}

		function freeDropObject(){
			stickToCursor = false;
			confirmDropObject();
		}

		function stackObjectOnTop(){
			stickToCursor = false;
			selectedPackage.userData.packageData.underPackage = collidingObject;
			collidingObject.userData.packageData.topPackage = selectedPackage;
			const otherPackageTop = collidingObject.position.y + getPackageHeight(collidingObject);
			selectedPackage.position.y = otherPackageTop + getPackageHeight(selectedPackage);
			selectedPackage.position.z = collidingObject.position.z;
			selectedPackage.position.x = collidingObject.position.x;
			confirmDropObject();
		}

		function snapPackageToCollider() {			
			stickToCursor = false;
			if (selectedPackage && collidingObject) {
				// Get bounding boxes of the selected package and the colliding object
				const selectedBox = new THREE.Box3().setFromObject(selectedPackage);
				const collidingBox = new THREE.Box3().setFromObject(collidingObject);

				// Calculate the center of the selected package
				const selectedCenter = new THREE.Vector3();
				selectedBox.getCenter(selectedCenter);

				// Calculate the center and size of the colliding object
				const collidingCenter = new THREE.Vector3();
				collidingBox.getCenter(collidingCenter);

				const collidingSize = new THREE.Vector3();
				collidingBox.getSize(collidingSize);

				// Calculate face positions relative to the colliding object
				const packageHeightCalculated = getPackageHeight(selectedPackage)
				const faces = getFaces(collidingCenter,packageHeightCalculated,collidingBox)

				// Find the closest face
				let closestFace = null;
				let minDistance = Infinity;

				for (const [face, position] of Object.entries(faces)) {
					const distance = selectedCenter.distanceTo(position);
					if (distance < minDistance) {
						minDistance = distance;
						closestFace = face;
					}
				}

				// Calculate the size of the selected package
				const selectedSize = new THREE.Vector3();
				selectedBox.getSize(selectedSize);
				snapToClosestFace(closestFace,packageHeightCalculated,collidingCenter,collidingBox,selectedSize)
			}
			confirmDropObject();
		}

		function getFaces(collidingCenter,packageHeightCalculated,collidingBox){
			return {
					front: new THREE.Vector3(collidingCenter.x, packageHeightCalculated, collidingBox.max.z),
					back: new THREE.Vector3(collidingCenter.x, packageHeightCalculated, collidingBox.min.z),
					left: new THREE.Vector3(collidingBox.min.x, packageHeightCalculated, collidingCenter.z),
					right: new THREE.Vector3(collidingBox.max.x, packageHeightCalculated, collidingCenter.z),
				};
		}

		function snapToClosestFace(closestFace,packageHeight,collidingCenter,collidingBox,selectedSize){
			switch (closestFace) {
				case 'front':
					selectedPackage.position.set(
						collidingCenter.x,
						packageHeight,
						collidingBox.max.z + selectedSize.z / 2
					);
					break;
				case 'back':
					selectedPackage.position.set(
						collidingCenter.x,
						packageHeight,
						collidingBox.min.z - selectedSize.z / 2
					);
					break;
				case 'left':
					selectedPackage.position.set(
						collidingBox.min.x - selectedSize.x / 2,
						packageHeight,
						collidingCenter.z
					);
					break;
				case 'right':
					selectedPackage.position.set(
						collidingBox.max.x + selectedSize.x / 2,
						packageHeight,
						collidingCenter.z
					);
					break;
			}
		}

		function confirmDropObject(){
			if(confirmSafePlace()){
				if(isBoxInsideWarehouse()){
					document.getElementById("warningMessage").style.display = "none";  // Hide warning message
					hideEdges();
				}else{
					changeEdgeColor(redColor);
				}
				clearSelectedObjectData();
			}else{
				stickToCursor = true
				showNotification('notificationInvalidPlace',2000)
			}
		}

		function confirmSafePlace(){
			if(selectedPackage){
				const selectedPackageOriginalCollision = new THREE.Box3().setFromObject(selectedPackage);
				const selectedPackageCollision =  new THREE.Box3(
					selectedPackageOriginalCollision.min.clone().addScalar(1),
					selectedPackageOriginalCollision.max.clone().addScalar(-1)
				);
				let existingCollisions = 0
				for(const obj of objects){
					const objCollision = new THREE.Box3().setFromObject(obj);
					if(selectedPackageCollision.intersectsBox(objCollision)){
						if (existingCollisions == 0){
							existingCollisions = 1
						}else{
							return false
						}
					}
				}
				return true;
			}else{
				return true;
			}
		}

		function checkCollisions(pkg){
			if(pkg){
				const selectedPackageOriginalCollision = new THREE.Box3().setFromObject(pkg);
				const selectedPackageCollision =  new THREE.Box3(
					selectedPackageOriginalCollision.min.clone().addScalar(-1),
					selectedPackageOriginalCollision.max.clone().addScalar(1)
				);
				let existingCollisions = 0
				for(const obj of objects){
					const objOriginalCollision = new THREE.Box3().setFromObject(obj);
					const objCollision =  new THREE.Box3(
						objOriginalCollision.min.clone().addScalar(-1),
						objOriginalCollision.max.clone().addScalar(1)
					);
					if(selectedPackageCollision.intersectsBox(objCollision)){
						if (existingCollisions == 0){
							existingCollisions = 1
						}else{
							return true
						}
					}
				}
				return false;
			}else{
				return false;
			}
		}

		function clearSelectedObjectData(){
			isColliding = false;
			collidingObject = null;
			selectedPackage = null;
		}

		function pickObject(xPos,zPos,yPos){
			if (isInEditor){
				clearSelectedObjectData()
				const intersects = raycaster.intersectObjects(objects, false);
				if (intersects.length > 0 && intersects[0].object.userData.type === 'parcel') {
					selectedPackage = intersects[0].object;
					if(selectedPackage.userData.packageData.topPackage != null){
						clearSelectedObjectData()
						stickToCursor = false
						const notification = document.getElementById('stackedNotification');
						notification.style.display = 'block';  
						setTimeout(() => {
							notification.style.display = 'none';  // Hide after 2 seconds
							isInEditor = true
						}, 2000);
					}else{
						addEdgesToPackage()
						clearStickyRefs()
						/** Set on outlines here **/
						stickToCursor = true;
						selectedPackage.position.x = xPos;
						selectedPackage.position.z = zPos;
						if (selectedPackage.userData.packageData.isRotated){
							selectedPackage.position.y = selectedPackage.geometry.parameters.width/2
						}else{
							selectedPackage.position.y = selectedPackage.geometry.parameters.height/2
						}
					}
				}
			}
		}

		function clearStickyRefs(){
			const underPackage = selectedPackage.userData.packageData.underPackage
			if(underPackage != null){
				selectedPackage.userData.packageData.underPackage = null
				underPackage.userData.packageData.topPackage = null
			}
		}

		function addEdgesToPackage() {
			if(selectedPackage){
				if (!selectedPackage.geometry) {
					console.error("The provided object does not have geometry.");
					return;
				}
				for (let i = selectedPackage.children.length - 1; i >= 0; i--) {
					const child = selectedPackage.children[i];
					if (child instanceof THREE.LineSegments) {
						return;
					}
				}
				// Create edges geometry from the selectedPackage's geometry
				const edgesGeometry = new THREE.EdgesGeometry(selectedPackage.geometry);
				// Create a material with white color
				const edgesMaterial = new THREE.LineBasicMaterial({ color: 0xFFFFFF });
				// Create the edges as LineSegments
				const edges = new THREE.LineSegments(edgesGeometry, edgesMaterial);
				// Add the edges to the scene
				selectedPackage.add(edges);
				// Return the edges for further manipulation if needed
				return edges;
			}
		}

		function hideEdges(){
			if(selectedPackage){
				for (let i = selectedPackage.children.length - 1; i >= 0; i--) {
					const child = selectedPackage.children[i];
					if (child instanceof THREE.LineSegments) {
						selectedPackage.remove(child);
					}
				}
			}
		}

		function changeEdgeColor(color) {
			if(selectedPackage){
				for (const child of selectedPackage.children) {
					// Check if the child is a LineSegments (edges)
					if (child instanceof THREE.LineSegments) {
						// Change the color of the material
						child.material.color.set(color);
					}
				}
			}
		}

		function EditObject(){
			if (isInEditor){
				const intersects = raycaster.intersectObjects(objects, false);
				if (intersects.length > 0 && intersects[0].object.userData.type === 'parcel') {
					rightClickedObject = intersects[0].object
				}
			}else{
				rightClickedObject = null
			}
		}

		function onDocumentKeyDown(event) {
			if (event.key === "Shift") {
				isShiftDown = true;
			}
		}

		function onDocumentKeyUp(event) {
			if (event.key === "Shift") {
				isShiftDown = false;
			}
		}

		function rotateParcel() {
			if(rightClickedObject){
				if (checkCollisions(rightClickedObject)){
					showNotification("collidingObjectNotification")
				}else{
					if (rightClickedObject.userData.packageData.isRotated){
						rightClickedObject.userData.packageData.isRotated = false
						rightClickedObject.position.y = rightClickedObject.geometry.parameters.height/2
						rightClickedObject.rotation.x = 0;
					}else{
						rightClickedObject.userData.packageData.isRotated = true
						rightClickedObject.position.y = rightClickedObject.geometry.parameters.width/2
						rightClickedObject.rotation.x = Math.PI / 2;
					}
					render();
				}
			}
			else if (selectedPackage) {
				if (checkCollisions(selectedPackage)){
					showNotification("collidingObjectNotification")
				}else{
					if (selectedPackage.userData.packageData.isRotated){
						selectedPackage.userData.packageData.isRotated = false
						selectedPackage.position.y = rightClickedObject.geometry.parameters.height/2
						selectedPackage.rotation.x = 0;
					}else{
						selectedPackage.userData.packageData.isRotated = true
						selectedPackage.position.y = rightClickedObject.geometry.parameters.width/2
						selectedPackage.rotation.x = Math.PI / 2;
					}
					render();
				}
			}
		}

		function copyParcel() {
			if(rightClickedObject && rightClickedObject.userData.type === 'parcel'){
				copyParcelByPackage(rightClickedObject);
				updateBoxList();
			}
			else if (selectedPackage && selectedPackage.userData.type === 'parcel') {
				copyParcelByPackage(selectedPackage);
				updateBoxList();
			}
		}

		function deleteParcel() {
			if(rightClickedObject.userData.type === 'parcel'){
				if (rightClickedObject.userData.packageData.topPackage != null){
					showNotification("collidingObjectNotification")
					return ;
				}
				const index = objects.indexOf(rightClickedObject);
				if (index !== -1) {
					deleteParcelByIndex(index);
					updateBoxList();
				}
			}
			else if (selectedPackage.userData.type === 'parcel') {
				if (selectedPackage.userData.packageData.topPackage != null){
					showNotification("collidingObjectNotification")
					return ;
				}
				const index = objects.indexOf(selectedPackage);
				if (index !== -1) {
					deleteParcelByIndex(index);
					updateBoxList();
				}
			}
		}

		function updateBoxList() {
			const boxList = document.getElementById("boxListItems");
			boxList.innerHTML = "";  // Clear the current list

			objects.forEach((obj, index) => {
				if (obj.userData && obj.userData.packageData) {
					const packageData = obj.userData.packageData;

					const li = document.createElement("li");

					li.innerHTML = `
				<div class="package-header">
					<strong>${packageData.name}</strong>
					<div class="action-icons">
						<button class="edit-btn" data-index="${index}">Edit</button>
						<button class="copy-btn" data-index="${index}">Copy</button>
						<button class="delete-btn" data-index="${index}">Delete</button>
					</div>
				</div>
				<div class="package-details">
					<div class="detail-row">
						<p><strong>Width:</strong> ${packageData.width}</p>
						<p><strong>Height:</strong> ${packageData.height}</p>
					</div>
					<div class="detail-row">
						<p><strong>Length:</strong> ${packageData.length}</p>
						<p><strong>Weight:</strong> ${packageData.weight}kg</p>
						<p><strong>Color:</strong> ${packageData.color}</p>

					</div>
					<div class="detail-row">
						<p><strong>Note:</strong> ${packageData.note}</p>
						<p><strong>Can Stack:</strong> ${packageData.canStack ? 'Yes' : 'No'}</p>
					</div>
					<!-- Placeholder for cursor position that will be replaced -->
				<div class="cursor-position">
					<p><strong>Cursor Position:</strong> <span id="cursor-coordinates">X: 0, Y: 0</span></p>
				</div>
							</div>
						`;

					boxList.appendChild(li);
				}
			});

			document.querySelectorAll("#boxListItems .edit-btn").forEach(button => {
				button.addEventListener("click", (event) => {
					const index = event.target.dataset.index;
					editPackage(index);  // Pass the selected package to edit function
				});
			});

			document.querySelectorAll("#boxListItems .copy-btn").forEach(button => {
				button.addEventListener("click", (event) => {
					const index = event.target.dataset.index;
					const selectedPackage = objects[index];
					copyParcelByPackage(selectedPackage);  // Pass the selected package to copy function
				});
			});

			document.querySelectorAll("#boxListItems .delete-btn").forEach(button => {
				button.addEventListener("click", (event) => {
					const index = event.target.dataset.index;
					deleteParcelByIndex(index);  // Pass the selected package to delete function
				});
			});
		}

		function copyParcelByPackage(mPackage) {

			const packageData = mPackage.userData.packageData;

			if (!packageData) {
				console.error('Package data missing.');
				return; // Exit if no valid package data
			}
			packageData.underPackage = null
			packageData.topPackage = null
			packageData.leftPackage = null
			packageData.rightPackage = null
			packageData.frontPackage = null
			packageData.backPackage = null

			const clonePackage = { ...packageData };

			const packageMesh = new THREE.Mesh(
				new THREE.BoxGeometry(clonePackage.width, clonePackage.height, clonePackage.length),
				new THREE.MeshLambertMaterial({ color: new THREE.Color(clonePackage.color) })
			);

			packageMesh.userData = {
				type: 'parcel',
				packageData: clonePackage
			};

			const randomX = Math.floor(Math.random() * warehouseDimensions.width) - warehouseDimensions.width / 2;
			const randomZ = Math.floor(Math.random() * warehouseDimensions.length) - warehouseDimensions.length / 2;

			packageMesh.position.set(randomX, getPackageHeight(mPackage), randomZ);

			scene.add(packageMesh);
			objects.push(packageMesh);
			packages.push(clonePackage);

			updateBoxList();
			calculateTotalWeight();
			if (totalWeight>warehouseDimensions.weightLimit){
				showNotification("weightLimitNotification");
			};
			render();
		}

		function deleteParcelByIndex(index) {
			const packageMesh = objects[index];

			scene.remove(packageMesh);

			packageMesh.geometry.dispose();
			packageMesh.material.dispose();

			objects.splice(index, 1);
			packages.splice(index, 1);

			updateBoxList();

			calculateTotalWeight();
			render();
		}


		function onWindowResize() {
			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();
			renderer.setSize(window.innerWidth, window.innerHeight);
		}

		function render() {
			cameraControls.update();
			renderer.render(scene, camera);
		}

	</script>
</body>
</html>