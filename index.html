<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0" />
	<title>Parcel Placement and Warehouse Management</title>
	<link rel="stylesheet" href="main.css" />

</head>

<body>
	<div id="sidebar">
		<h3>Warehouse Dimensions</h3>
		<label for="width">Width:</label>
		<input type="number" id="width" value="750" />
		<br />
		<label for="length">Length:</label>
		<input type="number" id="length" value="650" />
		<br />
		<label for="height">Height:</label>
		<input type="number" id="height" value="450" />
		<br />
		<label for="weight-limit">Weight Limit:</label>
		<input type="number" id="weight-limit" value="1000" />
		<br />
		<button id="apply">Apply</button>
		<h4>Boxes</h4>
		<div id="boxList">
			<ul id="boxListItems"></ul>
		</div>
		<button id="addPackageButton">Add Package</button>
	</div>

	<div id="contextMenu">
		<button id="rotateButton">Rotate 90 degrees</button>
		<button id="editButton">Edit</button>
		<button id="copyButton">Copy</button>
		<button id="deleteButton">Delete</button>
	</div>

	<div id="modal">
		<div id="modal-content">
			<span class="close">&times;</span>
			<h3>Add New Package</h3>

			<div class="modal-row">
				<label for="modal-name">Name:</label>
				<input type="text" id="modal-name" placeholder="Enter package name" required />
			</div>

			<div class="modal-row">
				<label for="modal-color">Color:</label>
				<input type="text" id="modal-color" placeholder="Enter package color" required />
			</div>

			<div class="modal-row">
				<label for="modal-width">Width:</label>
				<input type="number" id="modal-width" placeholder="Enter package width" required />
			</div>

			<div class="modal-row">
				<label for="modal-length">Length:</label>
				<input type="number" id="modal-length" placeholder="Enter package length" required />
			</div>

			<div class="modal-row">
				<label for="modal-height">Height:</label>
				<input type="number" id="modal-height" placeholder="Enter package height" required />
			</div>

			<div class="modal-row">
				<label for="modal-weight">Weight:</label>
				<input type="number" id="modal-weight" placeholder="Enter package weight" required />
			</div>

			<div class="modal-row">
				<label for="modal-note">Note:</label>
				<input type="text" id="modal-note" placeholder="Enter package note" />
			</div>

			<div class="modal-row">
				<label for="modal-stack">Can stack?</label>
				<input type="checkbox" id="modal-stack" />
			</div>

			<div class="modal-row">
				<button id="savePackageButton">Submit Package</button>
			</div>
		</div>
	</div>

	<div id="notification"
		style="display:none; background-color: #f44336; color: white; padding: 15px; position: fixed; top: 20px; left: 50%; transform: translateX(-50%); z-index: 1000;">
		This package cannot be placed on top of a non-stackable package.
	</div>

	<div id="weightNotification"
		style="display:none; background-color: #f44336; color: white; padding: 15px; position: fixed; top: 20px; left: 50%; transform: translateX(-50%); z-index: 1000;">
		This package cannot be placed on top of a lighter package.
	</div>

	<div id="manyCollisionsNotification"
		style="display:none; background-color: #f44336; color: white; padding: 15px; position: fixed; top: 20px; left: 50%; transform: translateX(-50%); z-index: 1000;">
		Many collisions to handle.
	</div>

	<div id="scaleNotification"
		style="display:none; background-color: #f44336; color: white; padding: 15px; position: fixed; top: 20px; left: 50%; transform: translateX(-50%); z-index: 1000;">
		This package cannot be placed on top of a smaller package.
	</div>

	<div id="stackedNotification"
		style="display:none; background-color: #f44336; color: white; padding: 15px; position: fixed; top: 20px; left: 50%; transform: translateX(-50%); z-index: 1000;">
		Can not move understacked package.
	</div>

	<div id="editNotification"
		style="display:none; background-color: #f44336; color: white; padding: 15px; position: fixed; top: 20px; left: 50%; transform: translateX(-50%); z-index: 1000;">
		Can edit while moving a package.
	</div>

	<div id="warningMessage"
		style="display:none; position: fixed; top: 10px; left: 50%; transform: translateX(-50%); padding: 10px; background-color: yellow; color: red; font-size: 16px; border-radius: 5px;">
		Warning: The package is outside the warehouse!
	</div>

	<script type="importmap">
        {
            "imports": {
                "three": "./build/three.module.js",
                "three/addons/": "./jsm/"
            }
        }
    </script>

	<script type="module">
		import * as THREE from "three";
		import { OrbitControls } from "./jsm/controls/OrbitControls.js";

		let camera, scene, renderer;
		let raycaster, isShiftDown = false;
		let pointer = new THREE.Vector2();
		let rollOverMesh;
		let cubeGeo, cubeMaterial;
		let cursorOffset = new THREE.Vector3(); 

		const objects = [];
		let totalWeight = 0;
		let selectedPackage = null;
		let edittingPackage = null;
		let contextMenuVisible = false;
		let isDragging = false;
		let cameraControls;
		let plane;
		let warehouseGroup;
		let isColliding = false;
		let stickToCursor = false; 
		let collidingObject = null;
		let rightClickedObject = null;

		let selectedPackageEdges = null; 

		let stackCounter = 0
		let canStack = true;
		let canPlace = false
		let isInsideWarehouseCheck = false
		let pressStartTime; // To store the timestamp when the pointer is pressed
		const LONG_PRESS_THRESHOLD = 500; // Threshold in milliseconds for a long press

		const mousePositionInWorld = new THREE.Vector3(); // For storing the result

		const targetY = 0; //I prefer using constants instead of numbers

		let isInEditor = true

		let warehouseDimensions = {
			width: 500,
			length: 500,
			height: 350,
			weightLimit: 1000,
		};

		const packages = [];

		init();
		render();

		function init() {
			camera = new THREE.PerspectiveCamera(20, window.innerWidth / window.innerHeight, 1, 10000);
			camera.position.set(0, 500, 1500);
			camera.lookAt(0, 0, 0);

			scene = new THREE.Scene();
			scene.background = new THREE.Color(0x333333);

			const gridHelper = new THREE.GridHelper(1500, 15);
			gridHelper.position.y = 0;
			scene.add(gridHelper);

			const rollOverGeometry = new THREE.BoxGeometry(100, 100, 100);
			const rollOverMaterial = new THREE.MeshBasicMaterial({
				color: 0x999999,
				wireframe: true,
				transparent: true,
				opacity: 0
			});
			rollOverMesh = new THREE.Mesh(rollOverGeometry, rollOverMaterial);
			scene.add(rollOverMesh);  // Add rollOverMesh to the scene


			raycaster = new THREE.Raycaster();
			pointer = new THREE.Vector2();
			createWarehouseSurface();


			const ambientLight = new THREE.AmbientLight(0x606060, 3);
			scene.add(ambientLight);

			const directionalLight = new THREE.DirectionalLight(0xffffff, 3);
			directionalLight.position.set(1, 0.75, 0.5).normalize();
			scene.add(directionalLight);

			renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);
			document.body.appendChild(renderer.domElement);

			cameraControls = new OrbitControls(camera, renderer.domElement);
			cameraControls.enableDamping = true;
			cameraControls.dampingFactor = 0.25;
			cameraControls.autoRotation = true;
			cameraControls.screenSpacePanning = false;

			document.addEventListener("pointermove", onPointerMove);
			document.addEventListener("pointerdown", onPointerDown);
			document.addEventListener("pointerup", onPointerUp);
			document.addEventListener("keydown", onDocumentKeyDown);
			document.addEventListener("keyup", onDocumentKeyUp);
			window.addEventListener("resize", onWindowResize);

			document.addEventListener("contextmenu", onRightClick);
			document.addEventListener("click", onLeftClick);

			document.getElementById("apply").addEventListener("click", function () {
				warehouseDimensions.width = parseFloat(document.getElementById("width").value);
				warehouseDimensions.length = parseFloat(document.getElementById("length").value);
				warehouseDimensions.height = parseFloat(document.getElementById("height").value);
				warehouseDimensions.weightLimit = parseFloat(document.getElementById("weight-limit").value);
				createWarehouseSurface();

			});

			document.getElementById("rotateButton").addEventListener("click", rotateParcel);
			document.getElementById("editButton").addEventListener("click", editPackage);
			document.getElementById("copyButton").addEventListener("click", copyParcel);
			document.getElementById("deleteButton").addEventListener("click", deleteParcel);


			document.querySelector(".close").addEventListener("click", closeModal);
		}

		let isEditing = false;

		document.getElementById("addPackageButton").addEventListener("click", openModal);

		document.getElementById("savePackageButton").addEventListener("click", function () {
			if (isEditing) {
				saveEditedPackage();
			} else {
				addPackage();
			}
		});

		function calculateTotalWeight() {
			return packages.reduce((total, packageData) => total + packageData.weight, 0);
		}

		function editPackage(index = null) {
			isInEditor = false;
			if (index !== undefined && index !== null && index >= 0) {

				const pkg = packages[index];
				const mesh = objects[index];

				if (!pkg || !mesh) {
					alert("Package or mesh not found.");
					isInEditor = true;
					return;
				}

				edittingPackage = mesh;

				document.getElementById("modal-name").value = pkg.name || "";
				document.getElementById("modal-width").value = pkg.width || 100;
				document.getElementById("modal-length").value = pkg.length || 100;
				document.getElementById("modal-height").value = pkg.height || 100;
				document.getElementById("modal-color").value = pkg.color || white;
				document.getElementById("modal-weight").value = pkg.weight || 100;
				document.getElementById("modal-note").value = pkg.note || "";
				document.getElementById("modal-stack").checked = pkg.canStack || false;

				document.getElementById("modal").style.display = "flex";

				isEditing = true;

			} else if (edittingPackage) {

				const packageData = edittingPackage.userData.packageData;

				if (!packageData) {
					alert("Package data is missing.");
					isInEditor = true;
					return;
				}

				document.getElementById("modal-name").value = packageData.name || "";
				document.getElementById("modal-width").value = packageData.width;
				document.getElementById("modal-length").value = packageData.length;
				document.getElementById("modal-height").value = packageData.height;
				document.getElementById("modal-color").value = packageData.color;
				document.getElementById("modal-weight").value = packageData.weight;
				document.getElementById("modal-note").value = packageData.note || "";
				document.getElementById("modal-stack").checked = packageData.canStack || false;

				document.getElementById("modal").style.display = "flex";

				isEditing = true;
			} else if(rightClickedObject){
				edittingPackage = rightClickedObject
				const packageData = edittingPackage.userData.packageData;

				if (!packageData) {
					alert("Package data is missing.");
					isInEditor = true;
					return;
				}

				document.getElementById("modal-name").value = packageData.name || "";
				document.getElementById("modal-width").value = packageData.width;
				document.getElementById("modal-length").value = packageData.length;
				document.getElementById("modal-height").value = packageData.height;
				document.getElementById("modal-color").value = packageData.color;
				document.getElementById("modal-weight").value = packageData.weight;
				document.getElementById("modal-note").value = packageData.note || "";
				document.getElementById("modal-stack").checked = packageData.canStack || false;

				document.getElementById("modal").style.display = "flex";

				isEditing = true;
			}else{
				isInEditor = true;
				alert("No package selected.");
			}
		}

		function saveEditedPackage() {
			if (!edittingPackage) {
				alert("No package selected.");
				clearEditPackageData();
				return;
			}

			const packageData = edittingPackage.userData.packageData;

			if (!packageData) {
				alert("Package data is missing.");
				clearEditPackageData();
				return;
			}

			const updatedName = document.getElementById("modal-name").value;
			const updatedWidth = parseFloat(document.getElementById("modal-width").value || 100);
			const updatedLength = parseFloat(document.getElementById("modal-length").value || 100);
			const updatedHeight = parseFloat(document.getElementById("modal-height").value || 100);
			const updatedColor = document.getElementById("modal-color").value || "white";
			const updatedWeight = parseFloat(document.getElementById("modal-weight").value || 100);
			const updatedNote = document.getElementById("modal-note").value;
			const updatedCanStack = document.getElementById("modal-stack").checked;

			const totalWeight = calculateTotalWeight() - packageData.weight + updatedWeight;

			if (totalWeight > warehouseDimensions.weightLimit) {
				alert("The total weight exceeds the warehouse weight limit!");
				return;
			}

			packageData.name = updatedName;
			packageData.width = updatedWidth;
			packageData.length = updatedLength;
			packageData.height = updatedHeight;
			packageData.color = updatedColor;
			packageData.weight = updatedWeight;
			packageData.note = updatedNote;
			packageData.canStack = updatedCanStack;

			edittingPackage.geometry.dispose();
			edittingPackage.material.dispose();
			edittingPackage.geometry = new THREE.BoxGeometry(updatedWidth, updatedHeight, updatedLength);
			edittingPackage.material = new THREE.MeshLambertMaterial({ color: new THREE.Color(updatedColor) });
			if(packageData.isRotated){
				edittingPackage.position.y = packageData.width/2
			}else{
				edittingPackage.position.y = packageData.height/2
			}
			document.getElementById("modal").style.display = "none";

			updateBoxList();

			render();

			clearEditPackageData();
		}

		function clearEditPackageData(){
			rightClickedObject = null;
			edittingPackage = null;
			isEditing = false;
			isInEditor = true;
			rightClickedObject = null;
		}

		function openModal() {
			document.getElementById("modal").style.display = "flex";
			isEditing = false;
			isInEditor = false;
		}

		let margin = 5;

		let lastPosition = { x: -warehouseDimensions.width / 2 - margin, y: 45, z: -warehouseDimensions.length / 2 - margin };  // Starting point for placing packages


		function addPackage() {
			const name = document.getElementById("modal-name").value || "";
			const color = document.getElementById("modal-color").value || "red";
			const width = parseFloat(document.getElementById("modal-width").value || 100);
			const length = parseFloat(document.getElementById("modal-length").value || 100);
			const height = parseFloat(document.getElementById("modal-height").value || 100);
			const weight = parseFloat(document.getElementById("modal-weight").value || 100);
			const note = document.getElementById("modal-note").value;
			const canStack = document.getElementById("modal-stack").checked;
			const onTopPackage = null;
			const onUnderPackage = null;
			const isRotated = false;

			const totalWeight = calculateTotalWeight() + weight;

			if (totalWeight > warehouseDimensions.weightLimit) {
				alert("Weight limit exceeded! The package cannot be added.");
				return;
			}

			const newPackage = {
				name,
				color,
				width,
				length,
				height,
				weight,
				note,
				canStack,
				onTopPackage,
				onUnderPackage,
				isRotated,
				type: 'parcel',
			};

			const packageMesh = new THREE.Mesh(
				new THREE.BoxGeometry(width, height, length),
				new THREE.MeshLambertMaterial({ color: new THREE.Color(color) })
			);

			packageMesh.userData = { type: 'parcel', packageData: newPackage };

			for (const obj of objects) {
				if (obj !== packageMesh && obj.userData.type === 'parcel' && !obj.userData.packageData.canStack) {
					const otherPackage = obj;
					if (checkCollision(packageMesh, otherPackage).originalCollision) {
						const notification = document.getElementById('notification');
						notification.style.display = 'block';  
						setTimeout(() => {
							notification.style.display = 'none';  // Hide after 3 seconds
							isInEditor = true
						}, 3000);
						return;
					}
				}
			}


			const position = {
				x: lastPosition.x + width + 5, // Place the new package slightly to the right of the last one
				y: height/2, // Keep the height constant
				z: lastPosition.z, // Keep the z-position constant (or change if you want to move it in the z-direction)
			};
			let newX = lastPosition.x + width + 5;
			let newZ = lastPosition.z;

			newX = Math.max(Math.min(newX, warehouseDimensions.width / 2 - width / 2), -warehouseDimensions.width / 2 + width / 2);

			newZ = Math.max(Math.min(newZ, warehouseDimensions.length / 2 - length / 2), -warehouseDimensions.length / 2 + length / 2);

			packageMesh.position.set(newX, position.y, newZ);

			scene.add(packageMesh);
			objects.push(packageMesh);
			packages.push(newPackage);

			lastPosition.x = position.x + width;

			updateBoxList();
			render();
			closeModal();
		}

		function checkCollision(package1, package2, collisionMargin = -20) {
			// Create bounding boxes for both packages
			const box1 = new THREE.Box3().setFromObject(package1);
			const box2 = new THREE.Box3().setFromObject(package2);

			// Apply the margin by adjusting the min and max coordinates
			const box1WithMargin = new THREE.Box3(
				box1.min.clone().addScalar(-collisionMargin),
				box1.max.clone().addScalar(collisionMargin)
			);

			const box2WithMargin = new THREE.Box3(
				box2.min.clone().addScalar(-collisionMargin),
				box2.max.clone().addScalar(collisionMargin)
			);

			// Perform intersection checks
			const originalCollision = box1.intersectsBox(box2);
			const marginCollision = box1WithMargin.intersectsBox(box2WithMargin);

			// Return both results
			return {
				originalCollision,
				marginCollision,
			};
		}

		function checkTopCollision(selectedPackage, otherPackage, horizontalTolerance = -12.5) {
			const selectedBox = new THREE.Box3().setFromObject(selectedPackage);
			const otherBox = new THREE.Box3().setFromObject(otherPackage);

			const selectedTop = selectedBox.max.y;
			const selectedBottom = selectedBox.min.y;
			const otherTop = otherBox.max.y;
			const otherBottom = otherBox.min.y;

			const isNearTop = selectedTop > otherBottom && selectedBottom <= otherTop;

			const isHorizontallyOverlapping = selectedBox.min.x < otherBox.max.x + horizontalTolerance &&
				selectedBox.max.x > otherBox.min.x - horizontalTolerance &&
				selectedBox.min.z < otherBox.max.z && selectedBox.max.z > otherBox.min.z;

			if (isNearTop && isHorizontallyOverlapping) {
				return true;
			}

			return false;
		}

		function createWarehouseSurface() {
			if (warehouseGroup) {
				scene.remove(warehouseGroup);
			}

			const blackPlaneGeometry = new THREE.PlaneGeometry(warehouseDimensions.width, warehouseDimensions.length);
			const blackPlaneMaterial = new THREE.MeshBasicMaterial({ color: 0x1F4529 });
			const blackPlane = new THREE.Mesh(blackPlaneGeometry, blackPlaneMaterial);
			blackPlane.rotation.x = -Math.PI / 2;
			blackPlane.position.y = 0;

			const geometry = new THREE.BoxGeometry(
				warehouseDimensions.width,
				warehouseDimensions.height,
				warehouseDimensions.length
			);
			const surfaceMaterial = new THREE.MeshBasicMaterial({
				color: 0xffffff,
				transparent: true,
				opacity: 0,
			});
			const wireframeMaterial = new THREE.LineBasicMaterial({
				color: 0x000000,
				linewidth: 3
			});

			plane = new THREE.Mesh(geometry, surfaceMaterial);
			plane.position.set(0, warehouseDimensions.height, 0);

			const wireframeEdges = new THREE.EdgesGeometry(geometry);
			const wireframe = new THREE.LineSegments(wireframeEdges, wireframeMaterial);

			wireframe.position.set(0, warehouseDimensions.height / 2 + 5, 0); // Adjust the Y position, for example, move it slightly above

			warehouseGroup = new THREE.Group();
			warehouseGroup.add(blackPlane); // Add black plane beneath the grid
			warehouseGroup.add(plane);
			warehouseGroup.add(wireframe);

			scene.add(warehouseGroup);
			/**objects.push(plane);  // Add to objects array for raycasting purposes**/
			/**I think the plane should not be added to the same array of the clickable objects**/
		}

		function closeModal() {
			document.getElementById("modal").style.display = "none";
			clearEditPackageData()
		}

		let lastValidPosition = new THREE.Vector3();

		function getMousePosition(event) {
			/**Previous Camera Position Code
			pointer.set(
				(event.clientX / window.innerWidth) * 2 - 1,
				-(event.clientY / window.innerHeight) * 2 + 1
			);
			const ray = new THREE.Raycaster();
			ray.setFromCamera(pointer, camera);
			const intersects = ray.intersectObjects(objects, false);
			if (intersects.length > 0) {
				lastValidPosition.copy(intersects[0].point);
				return intersects[0].point;
			}
			return lastValidPosition;
			**/

			//Here is a new camera position script that does not rely on intersections
			
			// Convert screen coordinates to normalized device coordinates (NDC)
			pointer.set(
				(event.clientX / window.innerWidth) * 2 - 1, // X: -1 to 1
				-(event.clientY / window.innerHeight) * 2 + 1 // Y: -1 to 1
			);

			// Unproject the NDC into world space
			mousePositionInWorld.set(pointer.x, pointer.y, 0);
			mousePositionInWorld.unproject(camera);

			// Calculate direction from camera to mouse
			const cameraToWorld = mousePositionInWorld.clone().sub(camera.position).normalize();

			// Adjust Y to match the target plane (e.g., ground or a specific Y)
			const distance = (targetY - camera.position.y) / cameraToWorld.y;
			mousePositionInWorld.copy(camera.position).add(cameraToWorld.multiplyScalar(distance));

			return mousePositionInWorld;
		}


		function onPointerMove(event) {
			pointer.set(
				(event.clientX / window.innerWidth) * 2 - 1,
				-(event.clientY / window.innerHeight) * 2 + 1
			);
			raycaster.setFromCamera(pointer, camera);
			const intersects = raycaster.intersectObjects(objects, false);

			if (stickToCursor && selectedPackage) {
				if(!isInEditor){
					stickToCursor = false
					selectedPackage = false
				}else{
					const mousePos = getMousePosition(event);
					if (mousePos) {
						selectedPackage.position.x = mousePos.x;
						selectedPackage.position.z = mousePos.z;
					}
				}
				const isInsideWarehouse = isBoxInsideWarehouse(warehouseDimensions)

				if (!isInsideWarehouse) {
					isInsideWarehouseCheck = false
					changeEdgeColor(0xFF0000)
					document.getElementById("warningMessage").style.display = "block";  // Show warning message
				} else {
					changeEdgeColor(0x00FF00)
					isInsideWarehouseCheck = true
					document.getElementById("warningMessage").style.display = "none";  // Hide warning message
				}
				isColliding = true
				let collisionCount = 0
				for (const obj of objects) {
					if (obj !== selectedPackage && obj.userData.type === 'parcel') {
						const otherPackage = obj;
						const collisions = checkCollision(selectedPackage, otherPackage)
						const areColliding = collisions.originalCollision
						const areMarginColliding = collisions.marginCollision
						if (areColliding && obj.userData) {
							collisionCount = collisionCount + 1
							collidingObject = obj
							if (!areMarginColliding){
								if(stackCounter === 0){
									console.log("outside margin")
									changeEdgeColor(0x00FF00)
									canStack = false;
									canPlace = true;
									selectedPackage.position.y = getPackageHeight(selectedPackage);
								}
							}else{
								console.log("inside margin")
								stackCounter = stackCounter + 1
								const otherPackageTop = otherPackage.position.y + getPackageHeight(otherPackage);
								selectedPackage.position.y = otherPackageTop + getPackageHeight(selectedPackage);
							}
						}
					}
				}
				console.log("stack count is ",stackCounter)
				if (collisionCount == 0 ){
					stackCounter = 0
					console.log("collision count is 0")
					isColliding = false
					canPlace = true;
					if (selectedPackage){
						selectedPackage.position.y = getPackageHeight(selectedPackage)
					}
				}else if(collisionCount>1){
					canPlace = false;
					changeEdgeColor(0xFF0000);
					const notification = document.getElementById('manyCollisionsNotification');
					notification.style.display = 'block';
					setTimeout(() => {
						notification.style.display = 'none';
					}, 1000);
					console.log("can not stack")
				}else{
					if(stackCounter !=0 && collidingObject){
						if (collidingObject.userData.packageData.canStack) {
							changeEdgeColor(0x00FF00)
							canStack = true;
							canPlace = true;
							console.log("can stack")
						}else {
							changeEdgeColor(0xFF0000);
							canStack = false;
							canPlace = false;
							const notification = document.getElementById('notification');
							notification.style.display = 'block';
							setTimeout(() => {
								notification.style.display = 'none';
							}, 1000);
							console.log("can not stack")
						}
					}
				}
			}

			render();
		}

		function getPackageHeight(mPackage){
			if(mPackage !=null){
				if (mPackage.userData.packageData.isRotated){
					return mPackage.geometry.parameters.width/2
				}else{
					return mPackage.geometry.parameters.height/2
				}
			}else{
				return targetY;
			}
		}

		function getPackageWidth(mPackage){
			if(mPackage !=null){
				if (mPackage.userData.packageData.isRotated){
					return mPackage.geometry.parameters.height
				}else{
					return mPackage.geometry.parameters.width
				}
			}else{
				return targetY;
			}
		}

		function isBoxInsideWarehouse(warehouseDimensions) {
			// Get the dimensions of the box (package)
			const boxHalfWidth = selectedPackage.geometry.parameters.width / 2;
			const boxHalfLength = selectedPackage.geometry.parameters.depth / 2; // For length (z-axis)

			// Calculate the outer edges of the box
			const minX = selectedPackage.position.x - boxHalfWidth;
			const maxX = selectedPackage.position.x + boxHalfWidth;
			const minZ = selectedPackage.position.z - boxHalfLength;
			const maxZ = selectedPackage.position.z + boxHalfLength;

			// Warehouse boundaries with margin
			const warehouseMinX = -warehouseDimensions.width / 2;
			const warehouseMaxX = warehouseDimensions.width / 2;
			const warehouseMinZ = -warehouseDimensions.length / 2;
			const warehouseMaxZ = warehouseDimensions.length / 2;

			// Check if the box is entirely inside the warehouse
			const isInside =
				minX >= warehouseMinX &&
				maxX <= warehouseMaxX &&
				minZ >= warehouseMinZ &&
				maxZ <= warehouseMaxZ;

			return isInside;
		}

		function onPointerDown(event){
			if (event.button === 0) {
				console.log("Left click pressed.");
				if (contextMenuVisible) return;
				pressStartTime = Date.now();
			}
		}

		function onPointerUp(event) {
			if (event.button === 0) {
				console.log("Left click released.");
				if(!isInEditor){
					stickToCursor = false
					selectedPackage = false
					return;
				}
				/**MOVED FROM POINTER DOWN START**/

				/**WE NEED TO MAKE SURE THAT CAMERA MOVEMENT AND 
				 * DRAGGING AN OBJECT DO NOT HAPPEN IN THE SAME TIME
				 * THE BEST WAY IS TO TRIGGER BOTH OF THEN IN POINTER UP**/

				const pressDuration = Date.now() - pressStartTime;//This determines of the user clicked on an object
				if(pressDuration<LONG_PRESS_THRESHOLD){
					const mousePos = getMousePosition(event);

					if (mousePos) {
						if (stickToCursor){
							dropObject()
						}else{
							pickObject(mousePos.x,mousePos.z,targetY)
						}
					}
					return
				}
				/**MOVED FROM POINTER DOWN END**/
				if (isDragging) {
					isDragging = false;
					cameraControls.enabled = true;
					document.getElementById("warningMessage").style.display = "none";
				}
			}
		}

		function dropObject(){
			/** Set off outlines here **/
			if(isInsideWarehouseCheck && canPlace){
				if(isColliding && collidingObject){
					if (canStack) {
						console.log("dropped object can stack")
						/** which means the object is being stacked **/
						if (getPackageWidth(selectedPackage) > getPackageWidth(collidingObject)){
							const notification = document.getElementById('scaleNotification');
							notification.style.display = 'block';  
							setTimeout(() => {
								notification.style.display = 'none';  // Hide after 2 seconds
								isInEditor = true
							}, 2000);
							return;
						}
						if (selectedPackage.userData.length > collidingObject.userData.packageData.length){
							const notification = document.getElementById('scaleNotification');
							notification.style.display = 'block';  
							setTimeout(() => {
								notification.style.display = 'none';  // Hide after 2 seconds
								isInEditor = true
							}, 2000);
							return;
						}
						if (selectedPackage.userData.packageData.weight > collidingObject.userData.packageData.weight){
							const notification = document.getElementById('weightNotification');
							notification.style.display = 'block';  
							setTimeout(() => {
								notification.style.display = 'none';  // Hide after 2 seconds
								isInEditor = true
							}, 2000);
							return;
						}
						stickToCursor = false;
						hideEdges()
						stackObjectOnTop()
						clearSelectedObjectData()
						return;
					}else {				
						console.log("dropped object can not stack")		
						stickToCursor = false;
						hideEdges()
						snapPackageToCollider()
						clearSelectedObjectData()
					}
				}else{
					if(isColliding){
						console.log("dropped object but colliding")
						const notification = document.getElementById('notification');
						notification.style.display = 'block';  
						setTimeout(() => {
							notification.style.display = 'none';  // Hide after 2 seconds
							isInEditor = true
						}, 2000);
						return;
					}else{
						console.log("dropped object not colliding")
						hideEdges()
						stickToCursor = false
						clearSelectedObjectData()
					}
				}
			}
		}

		function stackObjectOnTop(){
			selectedPackage.userData.packageData.onUnderPackage = collidingObject
			collidingObject.userData.packageData.onTopPackage = selectedPackage
			const otherPackageTop = collidingObject.position.y + getPackageHeight(collidingObject);
			selectedPackage.position.y = otherPackageTop + getPackageHeight(selectedPackage)
			selectedPackage.position.z = collidingObject.position.z
			selectedPackage.position.x = collidingObject.position.x
		}

		function snapPackageToCollider() {
			if (selectedPackage && collidingObject) {
				// Get bounding boxes of the selected package and the colliding object
				const selectedBox = new THREE.Box3().setFromObject(selectedPackage);
				const collidingBox = new THREE.Box3().setFromObject(collidingObject);

				// Calculate the center of the selected package
				const selectedCenter = new THREE.Vector3();
				selectedBox.getCenter(selectedCenter);

				// Calculate the center and size of the colliding object
				const collidingCenter = new THREE.Vector3();
				collidingBox.getCenter(collidingCenter);

				const collidingSize = new THREE.Vector3();
				collidingBox.getSize(collidingSize);

				// Calculate face positions relative to the colliding object
				const packageHeightCalculated = getPackageHeight(selectedPackage)
				const faces = {
					front: new THREE.Vector3(collidingCenter.x, packageHeightCalculated, collidingBox.max.z),
					back: new THREE.Vector3(collidingCenter.x, packageHeightCalculated, collidingBox.min.z),
					left: new THREE.Vector3(collidingBox.min.x, packageHeightCalculated, collidingCenter.z),
					right: new THREE.Vector3(collidingBox.max.x, packageHeightCalculated, collidingCenter.z),
				};

				// Find the closest face
				let closestFace = null;
				let minDistance = Infinity;

				for (const [face, position] of Object.entries(faces)) {
					const distance = selectedCenter.distanceTo(position);
					console.log(`Distance to ${face}:`, distance); // Debugging
					if (distance < minDistance) {
						minDistance = distance;
						closestFace = face;
					}
				}

				// Calculate the size of the selected package
				const selectedSize = new THREE.Vector3();
				selectedBox.getSize(selectedSize);

				// Snap the selected package to the closest face
				switch (closestFace) {
					case 'front':
						selectedPackage.position.set(
							collidingCenter.x,
							packageHeightCalculated,
							collidingBox.max.z + selectedSize.z / 2
						);
						break;
					case 'back':
						selectedPackage.position.set(
							collidingCenter.x,
							packageHeightCalculated,
							collidingBox.min.z - selectedSize.z / 2
						);
						break;
					case 'left':
						selectedPackage.position.set(
							collidingBox.min.x - selectedSize.x / 2,
							packageHeightCalculated,
							collidingCenter.z
						);
						break;
					case 'right':
						selectedPackage.position.set(
							collidingBox.max.x + selectedSize.x / 2,
							packageHeightCalculated,
							collidingCenter.z
						);
						break;
				}

				console.log(`Snapped to ${closestFace} face of the collider.`);
			} else {
				console.warn("No selected package or colliding object.");
			}
		}


		function clearSelectedObjectData(){
			isColliding = false;
			collidingObject = null;
			selectedPackage = null;
		}

		function pickObject(xPos,zPos,yPos){
			if (isInEditor){
				clearSelectedObjectData()
				const intersects = raycaster.intersectObjects(objects, false);
				if (intersects.length > 0 && intersects[0].object.userData.type === 'parcel') {
					selectedPackage = intersects[0].object;
					if(selectedPackage.userData.packageData.onTopPackage != null){
						clearSelectedObjectData()
						stickToCursor = false
						const notification = document.getElementById('stackedNotification');
						notification.style.display = 'block';  
						setTimeout(() => {
							notification.style.display = 'none';  // Hide after 2 seconds
							isInEditor = true
						}, 2000);
					}else{
						addEdgesToPackage()
						const underPackage = selectedPackage.userData.packageData.onUnderPackage
						if(underPackage != null){
							underPackage.userData.packageData.onTopPackage = null
						}
						/** Set on outlines here **/
						stickToCursor = true;
						selectedPackage.position.x = xPos;
						selectedPackage.position.z = zPos;
						if (selectedPackage.userData.packageData.isRotated){
							selectedPackage.position.y = selectedPackage.geometry.parameters.width/2
						}else{
							selectedPackage.position.y = selectedPackage.geometry.parameters.height/2
						}
					}
				}
			}
		}

		function addEdgesToPackage() {
			if(selectedPackage){
				if (!selectedPackage.geometry) {
					console.error("The provided object does not have geometry.");
					return;
				}
				// Create edges geometry from the selectedPackage's geometry
				const edgesGeometry = new THREE.EdgesGeometry(selectedPackage.geometry);
				// Create a material with white color
				const edgesMaterial = new THREE.LineBasicMaterial({ color: 0xFFFFFF });
				// Create the edges as LineSegments
				const edges = new THREE.LineSegments(edgesGeometry, edgesMaterial);
				// Add the edges to the scene
				selectedPackage.add(edges);
				// Return the edges for further manipulation if needed
				return edges;
			}
		}

		function hideEdges(){
			if(selectedPackage){
				for (let i = selectedPackage.children.length - 1; i >= 0; i--) {
					const child = selectedPackage.children[i];
					if (child instanceof THREE.LineSegments) {
						selectedPackage.remove(child);
					}
				}
			}
		}

		function changeEdgeColor(color) {
			for (const child of selectedPackage.children) {
				// Check if the child is a LineSegments (edges)
				if (child instanceof THREE.LineSegments) {
					// Change the color of the material
					child.material.color.set(color);
				}
			}
		}

		function onLeftClick(event) {
			const menu = document.getElementById("contextMenu");
			menu.style.display = "none";
			contextMenuVisible = false;

			if (isDragging) {
				isDragging = false;
				cameraControls.enabled = false;
				document.getElementById("warningMessage").style.display = "none";
			}

			render();
		}

		function onRightClick(event) {
			if (!stickToCursor){
				event.preventDefault();
				const mousePos = getMousePosition(event);
				EditObject()
				const menu = document.getElementById("contextMenu");
				const { clientX: mouseX, clientY: mouseY } = event;

				if (!rightClickedObject.userData.type === 'parcel') return;

				contextMenuVisible = true;
				menu.style.display = "block";
				menu.style.left = `${mouseX}px`;
				menu.style.top = `${mouseY}px`;
			}else{
				const notification = document.getElementById('editNotification');
				notification.style.display = 'block';  
				setTimeout(() => {
					notification.style.display = 'none';  // Hide after 2 seconds
					isInEditor = true
				}, 2000);
			}
		}

		function EditObject(){
			if (isInEditor){
				const intersects = raycaster.intersectObjects(objects, false);
				if (intersects.length > 0 && intersects[0].object.userData.type === 'parcel') {
					rightClickedObject = intersects[0].object
				}
			}else{
				rightClickedObject = null
			}
		}

		function onDocumentKeyDown(event) {
			if (event.key === "Shift") {
				isShiftDown = true;
			}
		}

		function onDocumentKeyUp(event) {
			if (event.key === "Shift") {
				isShiftDown = false;
			}
		}

		function rotateParcel() {
			if(rightClickedObject){
				if (rightClickedObject.userData.packageData.isRotated){
					rightClickedObject.userData.packageData.isRotated = false
					rightClickedObject.position.y = rightClickedObject.geometry.parameters.height/2
					rightClickedObject.rotation.x = 0;
				}else{
					rightClickedObject.userData.packageData.isRotated = true
					rightClickedObject.position.y = rightClickedObject.geometry.parameters.width/2
					rightClickedObject.rotation.x = Math.PI / 2;
				}
				render();
			}
			else if (selectedPackage) {
				if (selectedPackage.userData.packageData.isRotated){
					selectedPackage.userData.packageData.isRotated = false
					selectedPackage.position.y = rightClickedObject.geometry.parameters.height/2
					selectedPackage.rotation.x = 0;
				}else{
					selectedPackage.userData.packageData.isRotated = true
					selectedPackage.position.y = rightClickedObject.geometry.parameters.width/2
					selectedPackage.rotation.x = Math.PI / 2;
				}
				render();
			}
		}

		function copyParcel() {
			if(rightClickedObject && rightClickedObject.userData.type === 'parcel'){
				copyParcelByPackage(rightClickedObject);
				updateBoxList();
			}
			else if (selectedPackage && selectedPackage.userData.type === 'parcel') {
				copyParcelByPackage(selectedPackage);
				updateBoxList();
			}
		}

		function deleteParcel() {
			if(rightClickedObject.userData.type === 'parcel'){
				const index = objects.indexOf(rightClickedObject);
				if (index !== -1) {
					deleteParcelByIndex(index);
					updateBoxList();
				}
			}
			else if (selectedPackage.userData.type === 'parcel') {
				const index = objects.indexOf(selectedPackage);
				if (index !== -1) {
					deleteParcelByIndex(index);
					updateBoxList();
				}
			}
		}

		function updateBoxList() {
			const boxList = document.getElementById("boxListItems");
			boxList.innerHTML = "";  // Clear the current list

			objects.forEach((obj, index) => {
				if (obj.userData && obj.userData.packageData) {
					const packageData = obj.userData.packageData;

					const li = document.createElement("li");

					li.innerHTML = `
                <div class="package-header">
                    <strong>${packageData.name}</strong>
                    <div class="action-icons">
                        <button class="edit-btn" data-index="${index}">Edit</button>
                        <button class="copy-btn" data-index="${index}">Copy</button>
                        <button class="delete-btn" data-index="${index}">Delete</button>
                    </div>
                </div>
                <div class="package-details">
                    <div class="detail-row">
                        <p><strong>Width:</strong> ${packageData.width}</p>
                        <p><strong>Height:</strong> ${packageData.height}</p>
                    </div>
                    <div class="detail-row">
                        <p><strong>Length:</strong> ${packageData.length}</p>
                        <p><strong>Weight:</strong> ${packageData.weight}kg</p>
						<p><strong>Color:</strong> ${packageData.color}</p>

                    </div>
                    <div class="detail-row">
                        <p><strong>Note:</strong> ${packageData.note}</p>
                        <p><strong>Can Stack:</strong> ${packageData.canStack ? 'Yes' : 'No'}</p>
                    </div>
					<!-- Placeholder for cursor position that will be replaced -->
    <div class="cursor-position">
        <p><strong>Cursor Position:</strong> <span id="cursor-coordinates">X: 0, Y: 0</span></p>
    </div>
                </div>
            `;

					boxList.appendChild(li);
				}
			});

			document.querySelectorAll("#boxListItems .edit-btn").forEach(button => {
				button.addEventListener("click", (event) => {
					const index = event.target.dataset.index;
					editPackage(index);  // Pass the selected package to edit function
				});
			});

			document.querySelectorAll("#boxListItems .copy-btn").forEach(button => {
				button.addEventListener("click", (event) => {
					const index = event.target.dataset.index;
					const selectedPackage = objects[index];
					copyParcelByPackage(selectedPackage);  // Pass the selected package to copy function
				});
			});

			document.querySelectorAll("#boxListItems .delete-btn").forEach(button => {
				button.addEventListener("click", (event) => {
					const index = event.target.dataset.index;
					deleteParcelByIndex(index);  // Pass the selected package to delete function
				});
			});
		}

		function copyParcelByPackage(mPackage) {

			const packageData = mPackage.userData.packageData;

			if (!packageData) {
				console.error('Package data missing.');
				return; // Exit if no valid package data
			}
			packageData.onUnderPackage = null
			packageData.onTopPackage = null

			const clonePackage = { ...packageData };

			const totalWeight = calculateTotalWeight() + clonePackage.weight;

			if (totalWeight > warehouseDimensions.weightLimit) {
				alert("The total weight exceeds the warehouse weight limit!");
				return; // Exit the function if weight limit is exceeded
			}

			const packageMesh = new THREE.Mesh(
				new THREE.BoxGeometry(clonePackage.width, clonePackage.height, clonePackage.length),
				new THREE.MeshLambertMaterial({ color: new THREE.Color(clonePackage.color) })
			);

			packageMesh.userData = {
				type: 'parcel',
				packageData: clonePackage
			};

			const randomX = Math.floor(Math.random() * warehouseDimensions.width) - warehouseDimensions.width / 2;
			const randomZ = Math.floor(Math.random() * warehouseDimensions.length) - warehouseDimensions.length / 2;

			packageMesh.position.set(randomX, getPackageHeight(mPackage), randomZ);

			scene.add(packageMesh);
			objects.push(packageMesh);
			packages.push(clonePackage);

			updateBoxList();
			render();
		}

		function deleteParcelByIndex(index) {
			const packageMesh = objects[index];

			const packageWeight = packageMesh.userData.packageData.weight;

			const totalWeight = calculateTotalWeight() - packageWeight;

			scene.remove(packageMesh);

			packageMesh.geometry.dispose();
			packageMesh.material.dispose();

			objects.splice(index, 1);
			packages.splice(index, 1);

			updateBoxList();
			render();
		}


		function onWindowResize() {
			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();
			renderer.setSize(window.innerWidth, window.innerHeight);
		}

		function render() {
			cameraControls.update();
			renderer.render(scene, camera);
		}

	</script>
</body>
</html>