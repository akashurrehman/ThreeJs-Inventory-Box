<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0" />
	<title>Parcel Placement and Warehouse Management</title>
	<link rel="stylesheet" href="main.css" />

</head>

<body>
	<div id="sidebar">
		<h3>Warehouse Dimensions</h3>
		<label for="width">Width:</label>
		<input type="number" id="width" value="500" />
		<br />
		<label for="length">Length:</label>
		<input type="number" id="length" value="500" />
		<br />
		<label for="height">Height:</label>
		<input type="number" id="height" value="350" />
		<br />
		<label for="weight-limit">Weight Limit:</label>
		<input type="number" id="weight-limit" value="1000" />
		<br />
		<button id="apply">Apply</button>
		<br />
		<label  id="weightLimitLabel">Weight</label>
		<br />
		<h4>Options</h4>
		<label>
			<input type="checkbox" id="snapToEdges" checked/> Snap to Warehouse Edges
		</label>
		<br />
		<label>
			<input type="checkbox" id="snapToObjects" checked/> Snap to Other Objects
		</label>
		<br />
		<label>
			<input type="checkbox" id="autoStack" checked/> Auto Stack on Top
		</label>
		<br />
		<h5>Rotation Direction</h5>
		<label>
			<input type="radio" name="rotation" id="rotateHorizontal" checked /> Horizontally
		</label>
		<br />
		<label>
			<input type="radio" name="rotation" id="rotateVertical" /> Vertically
		</label>
		<h4>Boxes</h4>
		<div id="boxList">
			<ul id="boxListItems"></ul>
		</div>
		<button id="addPackageButton">Add Package</button>
	</div>

	<div id="contextMenu">
		<button id="rotateButton">Rotate 90 degrees</button>
		<button id="editButton">Edit</button>
		<button id="copyButton">Copy</button>
		<button id="deleteButton">Delete</button>
	</div>

	<div id="modal">
		<div id="modal-content">
			<span class="close">&times;</span>
			<h3>Add New Package</h3>

			<div class="modal-row">
				<label for="modal-name">Name:</label>
				<input type="text" id="modal-name" placeholder="Enter package name" required />
			</div>

			<div class="modal-row">
				<label for="modal-color">Color:</label>
				<input type="text" id="modal-color" placeholder="Enter package color" required />
			</div>

			<div class="modal-row">
				<label for="modal-width">Width:</label>
				<input type="number" id="modal-width" placeholder="Enter package width" required />
			</div>

			<div class="modal-row">
				<label for="modal-length">Length:</label>
				<input type="number" id="modal-length" placeholder="Enter package length" required />
			</div>

			<div class="modal-row">
				<label for="modal-height">Height:</label>
				<input type="number" id="modal-height" placeholder="Enter package height" required />
			</div>

			<div class="modal-row">
				<label for="modal-weight">Weight:</label>
				<input type="number" id="modal-weight" placeholder="Enter package weight" required />
			</div>

			<div class="modal-row">
				<label for="modal-note">Note:</label>
				<input type="text" id="modal-note" placeholder="Enter package note" />
			</div>

			<div class="modal-row">
				<label for="modal-stack">Can stack?</label>
				<input type="checkbox" id="modal-stack" />
			</div>

			<div class="modal-row">
				<button id="savePackageButton">Submit Package</button>
			</div>
		</div>
	</div>
	<div id="weightLimitNotification"
		style="display:none; background-color: #f44336; color: white; padding: 15px; position: fixed; top: 20px; left: 50%; transform: translateX(-50%); z-index: 1000;">
		Weight Limit Exceeded.
	</div>
	<div id="collidingObjectNotification"
		style="display:none; background-color: #f44336; color: white; padding: 15px; position: fixed; top: 20px; left: 50%; transform: translateX(-50%); z-index: 1000;">
		Can Not Edit A Colliding Package.
	</div>
	<div id="notification"
		style="display:none; background-color: #f44336; color: white; padding: 15px; position: fixed; top: 20px; left: 50%; transform: translateX(-50%); z-index: 1000;">
		This package cannot be placed on top of a non-stackable package.
	</div>

	<div id="notificationInvalidPlace"
		style="display:none; background-color: #f44336; color: white; padding: 15px; position: fixed; top: 20px; left: 50%; transform: translateX(-50%); z-index: 1000;">
		Package can not be placed here.
	</div>

	<div id="weightNotification"
		style="display:none; background-color: #f44336; color: white; padding: 15px; position: fixed; top: 20px; left: 50%; transform: translateX(-50%); z-index: 1000;">
		This package cannot be placed on top of a lighter package.
	</div>

	<div id="manyCollisionsNotification"
		style="display:none; background-color: #f44336; color: white; padding: 15px; position: fixed; top: 20px; left: 50%; transform: translateX(-50%); z-index: 1000;">
		Many collisions to handle.
	</div>

	<div id="scaleNotification"
		style="display:none; background-color: #f44336; color: white; padding: 15px; position: fixed; top: 20px; left: 50%; transform: translateX(-50%); z-index: 1000;">
		Package must completely fit on top of one under package.
	</div>

	<div id="stackedNotification"
		style="display:none; background-color: #f44336; color: white; padding: 15px; position: fixed; top: 20px; left: 50%; transform: translateX(-50%); z-index: 1000;">
		Can not move understacked package.
	</div>

	<div id="editNotification"
		style="display:none; background-color: #f44336; color: white; padding: 15px; position: fixed; top: 20px; left: 50%; transform: translateX(-50%); z-index: 1000;">
		Can edit while moving a package.
	</div>

	<div id="warningMessage"
		style="display:none; position: fixed; top: 10px; left: 50%; transform: translateX(-50%); padding: 10px; background-color: yellow; color: red; font-size: 16px; border-radius: 5px;">
		Warning: The package is outside the warehouse!
	</div>

	<script type="importmap">
        {
            "imports": {
                "three": "./build/three.module.js",
                "three/addons/": "./jsm/"
            }
        }
    </script>

	<script type="module">
		import * as THREE from "three";
		import { OrbitControls } from "./jsm/controls/OrbitControls.js";

		let camera, scene, renderer;
		let raycaster, isShiftDown = false;
		let pointer = new THREE.Vector2();
		let rollOverMesh;
		let cubeGeo, cubeMaterial;
		let cursorOffset = new THREE.Vector3(); 

		const objects = [];
		let totalWeight = 0;
		let selectedPackage = null;
		let edittingPackage = null;
		let contextMenuVisible = false;
		let isDragging = false;
		let cameraControls;
		let plane;
		let warehouseGroup;
		let isColliding = false;
		let stickToCursor = false; 
		let collidingObject = null;
		let rightClickedObject = null;

		let selectedPackageEdges = null; 

		const inBoundSnapMargin = 15
		const packageSnapMargin = 25
		let stackCounter = 0
		let pressStartTime; // To store the timestamp when the pointer is pressed
		const LONG_PRESS_THRESHOLD = 500; // Threshold in milliseconds for a long press
		const rotationDirections = {
			Horizental: "H",
			Vertical: "V",
		}
		let snapToWareHouseEdges = true;
		let snapToOtherObjects = true;
		let autoStackOnTop = true;
		let rotationDirection = rotationDirections.Horizental;


		const mousePositionInWorld = new THREE.Vector3(); // For storing the result

		const targetY = 0; //I prefer using constants instead of numbers

		const redColor = 0xFF0000
		const greenColor = 0x00FF00
		const whiteColor = 0xFFFFFF
		const blackColor = 0x000000

		let isInEditor = true

		let warehouseDimensions = {
			width: 500,
			length: 500,
			height: 350,
			weightLimit: 1000,
		};

		let startPositions = { x: -warehouseDimensions.width / 2, z: -warehouseDimensions.length / 2 };

		const packages = [];

		init();
		render();

		function init() {
			camera = new THREE.PerspectiveCamera(20, window.innerWidth / window.innerHeight, 1, 10000);
			camera.position.set(0, 500, 1500);
			camera.lookAt(0, 0, 0);

			scene = new THREE.Scene();
			scene.background = new THREE.Color(0x333333);

			const gridHelper = new THREE.GridHelper(1500, 15);
			gridHelper.position.y = 0;
			scene.add(gridHelper);

			const rollOverGeometry = new THREE.BoxGeometry(100, 100, 100);
			const rollOverMaterial = new THREE.MeshBasicMaterial({
				color: 0x999999,
				wireframe: true,
				transparent: true,
				opacity: 0
			});
			rollOverMesh = new THREE.Mesh(rollOverGeometry, rollOverMaterial);
			scene.add(rollOverMesh);  // Add rollOverMesh to the scene


			raycaster = new THREE.Raycaster();
			pointer = new THREE.Vector2();
			createWarehouseSurface();


			const ambientLight = new THREE.AmbientLight(0x606060, 3);
			scene.add(ambientLight);

			const directionalLight = new THREE.DirectionalLight(0xffffff, 3);
			directionalLight.position.set(1, 0.75, 0.5).normalize();
			scene.add(directionalLight);

			renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);
			document.body.appendChild(renderer.domElement);

			cameraControls = new OrbitControls(camera, renderer.domElement);
			cameraControls.enableDamping = true;
			cameraControls.dampingFactor = 0.25;
			cameraControls.autoRotation = true;
			cameraControls.screenSpacePanning = false;

			document.addEventListener("pointermove", onPointerMove);
			document.addEventListener("pointerdown", onPointerDown);
			document.addEventListener("pointerup", onPointerUp);
			document.addEventListener("keydown", onDocumentKeyDown);
			document.addEventListener("keyup", onDocumentKeyUp);
			window.addEventListener("resize", onWindowResize);
			snapToWareHouseEdges = document.getElementById("snapToEdges").checked;
			snapToOtherObjects = document.getElementById("snapToObjects").checked;
			autoStackOnTop = document.getElementById("autoStack").checked;
			if (document.getElementById("rotateHorizontal").checked){
				rotationDirection = rotationDirections.Horizental
			}else if (document.getElementById("rotateVertical").checked){
				rotationDirection = rotationDirections.Vertical
			}

			document.addEventListener("contextmenu", onRightClick);
			document.addEventListener("click", onLeftClick);
			document.getElementById("snapToEdges").addEventListener("change", (event) => {
				if (event.target.checked){
					snapToWareHouseEdges = true;
				}else{
					snapToWareHouseEdges = false;
				};
			});
			document.getElementById("snapToObjects").addEventListener("change", (event) => {
				if (event.target.checked){
					snapToOtherObjects = true;
				}else{
					snapToOtherObjects = false;
				};
			});
			document.getElementById("autoStack").addEventListener("change", (event) => {
				if (event.target.checked){
					autoStackOnTop = true;
				}else{
					autoStackOnTop = false;
				};
			});
			document.getElementsByName("rotation").forEach((radio) => {
				radio.addEventListener("change", (event) => {
					if (event.target.checked) {
						if (event.target.id == "rotateHorizontal"){
							rotationDirection = rotationDirections.Horizental
						}else if (event.target.id == "rotateVertical"){
							rotationDirection = rotationDirections.Vertical
						}
					}
				});
			});
			document.getElementById("apply").addEventListener("click", function () {
				warehouseDimensions.width = parseFloat(document.getElementById("width").value);
				warehouseDimensions.length = parseFloat(document.getElementById("length").value);
				warehouseDimensions.height = parseFloat(document.getElementById("height").value);
				warehouseDimensions.weightLimit = parseFloat(document.getElementById("weight-limit").value);
				document.getElementById("weightLimitLabel").innerHTML = "Weight: "+totalWeight+"/"+warehouseDimensions.weightLimit+" KG"
				calculateTotalWeight();
				if (totalWeight>warehouseDimensions.weightLimit){
					showNotification("weightLimitNotification");
				};
				createWarehouseSurface();
				startPositions = { x: -warehouseDimensions.width / 2, z: -warehouseDimensions.length / 2 };
			});
			document.getElementById("weightLimitLabel").style.color = "green"
			document.getElementById("weightLimitLabel").innerHTML= "Weight: "+totalWeight+"/"+warehouseDimensions.weightLimit+" KG"

			document.getElementById("rotateButton").addEventListener("click", rotateParcel);
			document.getElementById("editButton").addEventListener("click", editPackage);
			document.getElementById("copyButton").addEventListener("click", copyParcel);
			document.getElementById("deleteButton").addEventListener("click", deleteParcel);

			document.querySelector(".close").addEventListener("click", closeModal);
		}

		let isEditing = false;

		document.getElementById("addPackageButton").addEventListener("click", openModal);

		document.getElementById("savePackageButton").addEventListener("click", function () {
			if (isEditing) {
				saveEditedPackage();
			} else {
				addPackage();
			}
		});

		function calculateTotalWeight() {
			totalWeight = packages.reduce((total, packageData) => total + packageData.weight, 0);
			document.getElementById("weightLimitLabel").innerHTML= "Weight: "+totalWeight+"/"+warehouseDimensions.weightLimit+" KG"
			if (totalWeight>warehouseDimensions.weightLimit){
				document.getElementById("weightLimitLabel").style.color = "red"
			}else if (totalWeight==warehouseDimensions.weightLimit){
				document.getElementById("weightLimitLabel").style.color = "black"
			}else{
				document.getElementById("weightLimitLabel").style.color = "green"
			}
			return totalWeight;
		}

		function editPackage(index = null) {
			isInEditor = false;
			document.getElementById("modal-width").disabled = false;
			document.getElementById("modal-length").disabled = false;
			document.getElementById("modal-height").disabled = false;
			document.getElementById("modal-stack").disabled = false;
			if (index !== undefined && index !== null && index >= 0) {
				const pkg = packages[index];
				const mesh = objects[index];

				if (!pkg || !mesh) {
					alert("Package or mesh not found.");
					isInEditor = true;
					return;
				}
				let isMeshColliding = checkCollisions(mesh)

				edittingPackage = mesh;

				document.getElementById("modal-name").value = pkg.name || "";
				document.getElementById("modal-width").value = pkg.width || 100;
				document.getElementById("modal-length").value = pkg.length || 100;
				document.getElementById("modal-height").value = pkg.height || 100;
				document.getElementById("modal-color").value = pkg.color || white;
				document.getElementById("modal-weight").value = pkg.weight || 100;
				document.getElementById("modal-note").value = pkg.note || "";
				document.getElementById("modal-stack").checked = pkg.canStack || false;
				if (isMeshColliding){
					document.getElementById("modal-width").disabled = true;
					document.getElementById("modal-length").disabled = true;
					document.getElementById("modal-height").disabled = true;
				}else{
					document.getElementById("modal-width").disabled = false;
					document.getElementById("modal-length").disabled = false;
					document.getElementById("modal-height").disabled = false;
				}

				if(hasPackageOnTop(edittingPackage)){
					document.getElementById("modal-stack").disabled = true;
				}else{
					document.getElementById("modal-stack").disabled = false;
				}

				document.getElementById("modal").style.display = "flex";

				isEditing = true;

			} else if (edittingPackage) {

				const packageData = edittingPackage.userData.packageData;

				if (!packageData) {
					alert("Package data is missing.");
					isInEditor = true;
					return;
				}
				let isMeshColliding = checkCollisions(edittingPackage)

				document.getElementById("modal-name").value = packageData.name || "";
				document.getElementById("modal-width").value = packageData.width;
				document.getElementById("modal-length").value = packageData.length;
				document.getElementById("modal-height").value = packageData.height;
				document.getElementById("modal-color").value = packageData.color;
				document.getElementById("modal-weight").value = packageData.weight;
				document.getElementById("modal-note").value = packageData.note || "";
				document.getElementById("modal-stack").checked = packageData.canStack || false;
				if (isMeshColliding){
					document.getElementById("modal-width").disabled = true;
					document.getElementById("modal-length").disabled = true;
					document.getElementById("modal-height").disabled = true;
				}else{
					document.getElementById("modal-width").disabled = false;
					document.getElementById("modal-length").disabled = false;
					document.getElementById("modal-height").disabled = false;
				}

				if(hasPackageOnTop(edittingPackage)){
					document.getElementById("modal-stack").disabled = true;
				}else{
					document.getElementById("modal-stack").disabled = false;
				}

				document.getElementById("modal").style.display = "flex";

				isEditing = true;
			} else if(rightClickedObject != null){
				edittingPackage = rightClickedObject
				const packageData = edittingPackage.userData.packageData;
				let isMeshColliding = checkCollisions(rightClickedObject)

				if (!packageData) {
					alert("Package data is missing.");
					isInEditor = true;
					return;
				}

				document.getElementById("modal-name").value = packageData.name || "";
				document.getElementById("modal-width").value = packageData.width;
				document.getElementById("modal-length").value = packageData.length;
				document.getElementById("modal-height").value = packageData.height;
				document.getElementById("modal-color").value = packageData.color;
				document.getElementById("modal-weight").value = packageData.weight;
				document.getElementById("modal-note").value = packageData.note || "";
				document.getElementById("modal-stack").checked = packageData.canStack || false;
				if (isMeshColliding){
					document.getElementById("modal-width").disabled = true;
					document.getElementById("modal-length").disabled = true;
					document.getElementById("modal-height").disabled = true;
				}else{
					document.getElementById("modal-width").disabled = false;
					document.getElementById("modal-length").disabled = false;
					document.getElementById("modal-height").disabled = false;
				}

				if(hasPackageOnTop(edittingPackage)){
					document.getElementById("modal-stack").disabled = true;
				}else{
					document.getElementById("modal-stack").disabled = false;
				}

				document.getElementById("modal").style.display = "flex";

				isEditing = true;
			}else{
				isInEditor = true;
				alert("No package selected.");
			}
		}

		function saveEditedPackage() {
			if (!edittingPackage) {
				alert("No package selected.");
				clearEditPackageData();
				return;
			}

			const packageData = edittingPackage.userData.packageData;
			const testPackageData = edittingPackage.userData.packageData;

			if (!packageData) {
				alert("Package data is missing.");
				clearEditPackageData();
				return;
			}

			const updatedName = document.getElementById("modal-name").value;
			const updatedWidth = parseFloat(document.getElementById("modal-width").value || 100);
			const updatedLength = parseFloat(document.getElementById("modal-length").value || 100);
			const updatedHeight = parseFloat(document.getElementById("modal-height").value || 100);
			const updatedColor = document.getElementById("modal-color").value || "white";
			const updatedWeight = parseFloat(document.getElementById("modal-weight").value || 100);
			const updatedNote = document.getElementById("modal-note").value;
			const updatedCanStack = document.getElementById("modal-stack").checked;testPackageData.name = updatedName;
			// Check Safe Edit Start
			testPackageData.width = updatedWidth;
			testPackageData.length = updatedLength;
			testPackageData.height = updatedHeight;
			testPackageData.color = updatedColor;
			testPackageData.weight = updatedWeight;
			testPackageData.note = updatedNote;
			testPackageData.canStack = updatedCanStack;

			const packageTestMesh = new THREE.Mesh(
				new THREE.BoxGeometry(updatedWidth, updatedHeight, updatedLength)
			);
			packageTestMesh.userData = { type: 'parcel', packageData: testPackageData };

			packageTestMesh.position.copy(edittingPackage.position);

			const isTestMeshColliding = checkCollisions(packageTestMesh);
			const isOriginalMeshColliding = checkCollisions(edittingPackage);

			if (!isOriginalMeshColliding && isTestMeshColliding) {
				alert("Edited package should not collide with other objects. Please adjust its dimensions");
			}

			packageTestMesh.geometry.dispose();
			packageTestMesh.material.dispose();

			if (!isOriginalMeshColliding && isTestMeshColliding) {
				return;
			}
			// Check Safe Edit End

			packageData.name = updatedName;
			packageData.width = updatedWidth;
			packageData.length = updatedLength;
			packageData.height = updatedHeight;
			packageData.color = updatedColor;
			packageData.weight = updatedWeight;
			packageData.note = updatedNote;
			packageData.canStack = updatedCanStack;

			edittingPackage.geometry.dispose();
			edittingPackage.material.dispose();
			edittingPackage.geometry = new THREE.BoxGeometry(updatedWidth, updatedHeight, updatedLength);
			edittingPackage.material = new THREE.MeshLambertMaterial({ color: new THREE.Color(updatedColor) });
			
			const isMeshColliding = checkCollisions(edittingPackage)
			/** to prevent package from sinking to under package**/
			if (!isMeshColliding){
				edittingPackage.position.y = packageData.height/2
			}
			if (!isBoxInsideWarehouse(edittingPackage)) {
				hideEdges(edittingPackage)
				addEdgesToPackage(edittingPackage)
				changeEdgeColor(redColor,edittingPackage)
				document.getElementById("warningMessage").style.display = "block";  // Show warning message
			} else {
				hideEdges(edittingPackage)
				document.getElementById("warningMessage").style.display = "none";  // Hide warning message
			}
			document.getElementById("modal").style.display = "none";

			updateBoxList();

			calculateTotalWeight();
			if (totalWeight>warehouseDimensions.weightLimit){
				showNotification("weightLimitNotification");
			};

			render();

			clearEditPackageData();
		}

		function clearEditPackageData(){
			rightClickedObject = null;
			edittingPackage = null;
			isEditing = false;
			isInEditor = true;
			rightClickedObject = null;
		}

		function openModal() {
			document.getElementById("modal-width").disabled = false;
			document.getElementById("modal-length").disabled = false;
			document.getElementById("modal-height").disabled = false;
			document.getElementById("modal-stack").disabled = false;
			document.getElementById("modal").style.display = "flex";
			isEditing = false;
			isInEditor = false;
		}

		const margin = 5;

		function addPackage() {
			const name = document.getElementById("modal-name").value || "";
			const color = document.getElementById("modal-color").value || "red";
			const width = parseFloat(document.getElementById("modal-width").value || 100);
			const length = parseFloat(document.getElementById("modal-length").value || 100);
			const height = parseFloat(document.getElementById("modal-height").value || 100);
			const weight = parseFloat(document.getElementById("modal-weight").value || 100);
			const note = document.getElementById("modal-note").value;
			const canStack = document.getElementById("modal-stack").checked;

			const newPackage = {
				name,
				color,
				width,
				length,
				height,
				weight,
				note,
				canStack,
				type: 'parcel',
			};

			const packageMesh = new THREE.Mesh(
				new THREE.BoxGeometry(width, height, length),
				new THREE.MeshLambertMaterial({ color: new THREE.Color(color) })
			);

			packageMesh.userData = { type: 'parcel', packageData: newPackage };

			let isValidPosition = false;
			let attempts = 0;
			let maxAttempts = 1000;
			let newX = startPositions.x;
			let newZ = startPositions.z + length/2;

			while (!isValidPosition && attempts < maxAttempts) {
				newX = newX + width/2;
				if ((warehouseDimensions.width/2)<=newX){
					newX = startPositions.x  + width/2
					newZ = newZ + length/2;
				}
				if ((warehouseDimensions.length/2)<=newZ){
					isValidPosition = false;
					attempts = maxAttempts;
					break;
				}

				packageMesh.position.set(newX, height / 2, newZ);

				// Check for collisions with other objects
				isValidPosition = true;
				for (const obj of objects) {
					if (obj !== packageMesh && obj.userData.type === 'parcel') {
						const collisionResult = checkCollision(packageMesh, obj,-1);
						if (collisionResult.marginCollision) {
							isValidPosition = false;
							break;
						}
					}
				}
				attempts++;
			}

			if (!isValidPosition) {
				alert("Could not find a valid position for the package in the warehouse.");
				packageMesh.geometry.dispose();
				packageMesh.material.dispose();
				return;
			}

			// Add package to the scene
			scene.add(packageMesh);
			objects.push(packageMesh);
			packages.push(newPackage);
			if (!isBoxInsideWarehouse(packageMesh)) {
				hideEdges(packageMesh)
				addEdgesToPackage(packageMesh)
				changeEdgeColor(redColor,packageMesh)
				document.getElementById("warningMessage").style.display = "block";  // Show warning message
			} else {
				hideEdges(packageMesh)
				document.getElementById("warningMessage").style.display = "none";  // Hide warning message
			}

			updateBoxList();
			calculateTotalWeight();
			if (totalWeight > warehouseDimensions.weightLimit) {
				showNotification("weightLimitNotification");
			}

			render();
			closeModal();
		}

		function checkCollision(package1, package2, collisionMargin = -5) {
			// Create bounding boxes for both packages
			const box1 = new THREE.Box3().setFromObject(package1);
			const box2 = new THREE.Box3().setFromObject(package2);

			// Apply the margin by adjusting the min and max coordinates
			const box1WithMargin = new THREE.Box3(
				box1.min.clone().addScalar(-collisionMargin),
				box1.max.clone().addScalar(collisionMargin)
			);

			const box2WithMargin = new THREE.Box3(
				box2.min.clone().addScalar(-collisionMargin),
				box2.max.clone().addScalar(collisionMargin)
			);

			// Perform intersection checks
			const originalCollision = box1.intersectsBox(box2);
			const marginCollision = box1WithMargin.intersectsBox(box2WithMargin);

			// Return both results
			return {
				originalCollision,
				marginCollision,
			};
		}

		function createWarehouseSurface() {
			if (warehouseGroup) {
				scene.remove(warehouseGroup);
			}

			const blackPlaneGeometry = new THREE.PlaneGeometry(warehouseDimensions.width, warehouseDimensions.length);
			const blackPlaneMaterial = new THREE.MeshBasicMaterial({ color: 0x1F4529 });
			const blackPlane = new THREE.Mesh(blackPlaneGeometry, blackPlaneMaterial);
			blackPlane.rotation.x = -Math.PI / 2;
			blackPlane.position.y = 0;

			const geometry = new THREE.BoxGeometry(
				warehouseDimensions.width,
				warehouseDimensions.height,
				warehouseDimensions.length
			);
			const surfaceMaterial = new THREE.MeshBasicMaterial({
				color: 0xffffff,
				transparent: true,
				opacity: 0,
			});
			const wireframeMaterial = new THREE.LineBasicMaterial({
				color: 0x000000,
				linewidth: 3
			});

			plane = new THREE.Mesh(geometry, surfaceMaterial);
			plane.position.set(0, warehouseDimensions.height, 0);

			const wireframeEdges = new THREE.EdgesGeometry(geometry);
			const wireframe = new THREE.LineSegments(wireframeEdges, wireframeMaterial);

			wireframe.position.set(0, warehouseDimensions.height / 2, 0); // Adjust the Y position, for example, move it slightly above

			warehouseGroup = new THREE.Group();
			warehouseGroup.add(blackPlane); // Add black plane beneath the grid
			warehouseGroup.add(plane);
			warehouseGroup.add(wireframe);

			scene.add(warehouseGroup);
			/**objects.push(plane);  // Add to objects array for raycasting purposes**/
			/**I think the plane should not be added to the same array of the clickable objects**/
		}

		function closeModal() {
			document.getElementById("modal").style.display = "none";
			clearEditPackageData()
		}

		let lastValidPosition = new THREE.Vector3();

		function getMousePosition(event) {
			// Convert screen coordinates to normalized device coordinates (NDC)
			pointer.set(
				(event.clientX / window.innerWidth) * 2 - 1, // X: -1 to 1
				-(event.clientY / window.innerHeight) * 2 + 1 // Y: -1 to 1
			);

			// Unproject the NDC into world space
			mousePositionInWorld.set(pointer.x, pointer.y, 0);
			mousePositionInWorld.unproject(camera);

			// Calculate direction from camera to mouse
			const cameraToWorld = mousePositionInWorld.clone().sub(camera.position).normalize();

			// Adjust Y to match the target plane (e.g., ground or a specific Y)
			const distance = (- camera.position.y) / cameraToWorld.y;
			mousePositionInWorld.copy(camera.position).add(cameraToWorld.multiplyScalar(distance));

			return mousePositionInWorld;
		}


		function onPointerMove(event) {
			setPointer()
			if (stickToCursor && selectedPackage) {
				let collisionCount = 0;
				if(!isInEditor){
					stickToCursor = false
					selectedPackage = false
				}else{
					collisionCount = handlePackagePosition()
				}
				if (!isBoxInsideWarehouse()) {
					changeEdgeColor(redColor)
					document.getElementById("warningMessage").style.display = "block";  // Show warning message
				} else {
					changeEdgeColor(greenColor)
					document.getElementById("warningMessage").style.display = "none";  // Hide warning message
				}
				if (collisionCount == 0 ){
					handleNoCollisionLogic()
				}else{
					isColliding = true
					handleStackLogic()
				}
			}
			render();
		}

		function setPointer(){
			pointer.set(
				(event.clientX / window.innerWidth) * 2 - 1,
				-(event.clientY / window.innerHeight) * 2 + 1
			);
			raycaster.setFromCamera(pointer, camera);
		}

		function handlePackagePosition(){
			const mousePos = getMousePosition(event);
			let collisionCount = 0
			if (mousePos) {
				const packageCollisionResults = adjustPackageCollisionToCollider(mousePos)
				const adjustedToCollider = packageCollisionResults.isSticky;
				collisionCount = packageCollisionResults.collisionCount;
				if (!(adjustedToCollider || adjustPackagePositionToWareHouseBounds(mousePos))){
					selectedPackage.position.x = mousePos.x;
					selectedPackage.position.z = mousePos.z;
				}
			}
			return collisionCount
		}

		function adjustPackageCollisionToCollider(mousePos){
			let isSticky = false;
			let collisionCount = 0;
			collidingObject = undefined;
			for (const obj of objects) {
				if (obj !== selectedPackage && obj.userData.type === 'parcel') {
					const collisions = checkCollision(selectedPackage, obj);
					const areColliding = collisions.originalCollision;
					const areMarginColliding = collisions.marginCollision;
					if (areColliding && obj.userData) {
						collisionCount += 1;
						collidingObject = obj;
						if (areMarginColliding){
							stackCounter += 1;
							const otherPackageTop = collidingObject.position.y + getPackageHeight(collidingObject)/2;
							if (autoStackOnTop){
								selectedPackage.position.y = otherPackageTop + getPackageHeight(selectedPackage)/2;
							}else{
								selectedPackage.position.y = getPackageHeight(selectedPackage)/2;
							}
						}else{
							if(stackCounter === 0){
								changeEdgeColor(greenColor)
								selectedPackage.position.y = getPackageHeight(selectedPackage)/2;
							};
						}
						if (snapToOtherObjects){
							isSticky = stickPackageToCollider(mousePos)
						}else{
							isSticky = false
						}
					};
				};
			};
			return {isSticky,collisionCount};
		}

		function stickPackageToCollider(mousePos) {
			let isInBound = false;
			if (collidingObject) {
				const packageHalfWidth = getPackageWidth(selectedPackage) / 2;
				const packageHalfLength = selectedPackage.geometry.parameters.depth / 2;

				const colliderHalfWidth = getPackageWidth(collidingObject) / 2;
				const colliderHalfLength = collidingObject.geometry.parameters.depth / 2;

				const packageMinX = mousePos.x - packageHalfWidth;
				const packageMaxX = mousePos.x + packageHalfWidth;
				const packageMinZ = mousePos.z - packageHalfLength;
				const packageMaxZ = mousePos.z + packageHalfLength;

				const colliderMinX = collidingObject.position.x - colliderHalfWidth;
				const colliderMaxX = collidingObject.position.x + colliderHalfWidth;
				const colliderMinZ = collidingObject.position.z - colliderHalfLength;
				const colliderMaxZ = collidingObject.position.z + colliderHalfLength;

				const closeMinXToMinX = Math.abs(colliderMinX - packageMinX);
				const closeMinXToMaxX = Math.abs(colliderMinX - packageMaxX);
				const closeMaxXToMinX = Math.abs(colliderMaxX - packageMinX);
				const closeMaxXToMaxX = Math.abs(colliderMaxX - packageMaxX);

				let closestXDistance = Math.min(closeMinXToMinX, closeMinXToMaxX, closeMaxXToMinX, closeMaxXToMaxX);
				if (closestXDistance < packageSnapMargin) {
					if (closestXDistance === closeMinXToMinX) {
						selectedPackage.position.x = colliderMinX + packageHalfWidth;
					} else if (closestXDistance === closeMinXToMaxX) {
						selectedPackage.position.x = colliderMinX - packageHalfWidth;
					} else if (closestXDistance === closeMaxXToMinX) {
						selectedPackage.position.x = colliderMaxX + packageHalfWidth;
					} else if (closestXDistance === closeMaxXToMaxX) {
						selectedPackage.position.x = colliderMaxX - packageHalfWidth;
					}
					isInBound = true;
				} else {
					selectedPackage.position.x = mousePos.x;
				}

				const closeMinZToMinZ = Math.abs(colliderMinZ - packageMinZ);
				const closeMinZToMaxZ = Math.abs(colliderMinZ - packageMaxZ);
				const closeMaxZToMinZ = Math.abs(colliderMaxZ - packageMinZ);
				const closeMaxZToMaxZ = Math.abs(colliderMaxZ - packageMaxZ);

				let closestZDistance = Math.min(closeMinZToMinZ, closeMinZToMaxZ, closeMaxZToMinZ, closeMaxZToMaxZ);
				if (closestZDistance < packageSnapMargin) {
					if (closestZDistance === closeMinZToMinZ) {
						selectedPackage.position.z = colliderMinZ + packageHalfLength;
					} else if (closestZDistance === closeMinZToMaxZ) {
						selectedPackage.position.z = colliderMinZ - packageHalfLength;
					} else if (closestZDistance === closeMaxZToMinZ) {
						selectedPackage.position.z = colliderMaxZ + packageHalfLength;
					} else if (closestZDistance === closeMaxZToMaxZ) {
						selectedPackage.position.z = colliderMaxZ - packageHalfLength;
					}
					isInBound = true;
				} else {
					selectedPackage.position.z = mousePos.z;
				}
			}
			return isInBound;
		}


		function adjustPackagePositionToWareHouseBounds(mousePos){
			if (!snapToWareHouseEdges){
				return false;
			}
			const boxHalfWidth = getPackageWidth(selectedPackage) / 2;
			const boxHalfLength = selectedPackage.geometry.parameters.depth / 2; // For length (z-axis)

			const minX = mousePos.x - boxHalfWidth;
			const maxX = mousePos.x + boxHalfWidth;
			const minZ = mousePos.z - boxHalfLength;
			const maxZ = mousePos.z + boxHalfLength;

			const warehouseMinX = -warehouseDimensions.width / 2;
			const warehouseMaxX = warehouseDimensions.width / 2;
			const warehouseMinZ = -warehouseDimensions.length / 2;
			const warehouseMaxZ = warehouseDimensions.length / 2;

			const isCloseMinX = Math.abs(warehouseMinX-minX)
			const isCloseMaxX = Math.abs(warehouseMaxX-maxX)
			const isCloseMinZ = Math.abs(warehouseMinZ-minZ)
			const isCloseMaxZ = Math.abs(warehouseMaxZ-maxZ)
			let isInBound = false
			if (isCloseMinX<inBoundSnapMargin){
				if (isCloseMaxX<inBoundSnapMargin && isCloseMaxX<isCloseMinX){
					selectedPackage.position.x = warehouseMaxX - boxHalfWidth
					isInBound = true
				}else{
					selectedPackage.position.x = warehouseMinX + boxHalfWidth
					isInBound = true
				}
			}else if(isCloseMaxX<inBoundSnapMargin){
				selectedPackage.position.x = warehouseMaxX - boxHalfWidth
				isInBound = true
			}else{
				selectedPackage.position.x = mousePos.x;
			}
			if (isCloseMinZ<inBoundSnapMargin){
				if (isCloseMaxZ<inBoundSnapMargin && isCloseMaxZ<isCloseMinZ){
					selectedPackage.position.z = warehouseMaxZ - boxHalfLength
					isInBound = true
				}else{
					selectedPackage.position.z = warehouseMinZ + boxHalfLength
					isInBound = true
				}
			}else if(isCloseMaxZ<inBoundSnapMargin){
				selectedPackage.position.z = warehouseMaxZ - boxHalfLength
				isInBound = true
			}else{
				selectedPackage.position.z = mousePos.z;
			}

			return isInBound;
		}

		function handleNoCollisionLogic(){
			stackCounter = 0
			isColliding = false
			if (selectedPackage){
				selectedPackage.position.y = getPackageHeight(selectedPackage)/2
			}
		}

		function handleStackLogic(){
			if(stackCounter !=0 && collidingObject){
				if (collidingObject.userData.packageData.canStack) {
					changeEdgeColor(greenColor)
				}else {
					changeEdgeColor(redColor);
					const notification = document.getElementById('notification');
					notification.style.display = 'block';
					setTimeout(() => {
						notification.style.display = 'none';
					}, 1000);
				}
			}
		}

		function getPackageHeight(mPackage){
			if(mPackage !=null){
				return mPackage.geometry.parameters.height
			}else{
				return targetY;
			}
		}

		function getPackageWidth(mPackage){
			if(mPackage !=null){
				return mPackage.geometry.parameters.width
			}else{
				return targetY;
			}
		}

		/**
		 * Click Listeners Start
		 * **/
		function onPointerDown(event){
			if (event.button === 0) {
				if (contextMenuVisible) return;
				pressStartTime = Date.now();
			}
		}

		function onPointerUp(event) {
			if (event.button === 0) {
				if(!isInEditor){//This disables any interraction if user is editting or adding a package
					stickToCursor = false
					selectedPackage = false
					return;
				}
				/**WE NEED TO MAKE SURE THAT CAMERA MOVEMENT AND 
				 * DRAGGING AN OBJECT DO NOT HAPPEN IN THE SAME TIME
				 * THE BEST WAY IS TO TRIGGER BOTH OF THEN IN POINTER UP**/
				const pressDuration = Date.now() - pressStartTime;//This determines of the user clicked on an object
				if(pressDuration<LONG_PRESS_THRESHOLD){
					packageClicked()
				}else if (isDragging) {
					stopDragging()
				}
			}
		}

		function onLeftClick(event) {
			const menu = document.getElementById("contextMenu");
			menu.style.display = "none";
			contextMenuVisible = false;

			if (isDragging) {
				isDragging = false;
				cameraControls.enabled = false;
				document.getElementById("warningMessage").style.display = "none";
			}

			render();
		}

		function onRightClick(event) {
			if (!stickToCursor){
				event.preventDefault();
				const mousePos = getMousePosition(event);
				EditObject()
				const menu = document.getElementById("contextMenu");
				const { clientX: mouseX, clientY: mouseY } = event;

				if (rightClickedObject == null) return;
				if (!rightClickedObject.userData.type === 'parcel') return;

				contextMenuVisible = true;
				menu.style.display = "block";
				menu.style.left = `${mouseX}px`;
				menu.style.top = `${mouseY}px`;
			}else{
				const notification = document.getElementById('editNotification');
				notification.style.display = 'block';  
				setTimeout(() => {
					notification.style.display = 'none';  // Hide after 2 seconds
					isInEditor = true
				}, 2000);
			}
		}

		/**
		 * Click Listeners End
		 * **/

		function packageClicked(){
			const mousePos = getMousePosition(event);
			if (mousePos) {
				if (stickToCursor){
					dropObject()
				}else{
					pickObject(mousePos.x,mousePos.z,mousePos.y)
				}
			}
		}

		function stopDragging(){
			isDragging = false;
			cameraControls.enabled = true;
			document.getElementById("warningMessage").style.display = "none";
		}

		function dropObject(){
			/** Set off outlines here **/
			if(isColliding && collidingObject){
				console.log(`isColliding`)
				if (stackCounter > 0) {
					console.log(`stackCounter >`)
					if (checkCanStackObject()){
						stackObjectOnTop();
					}
				}else {	
					console.log(`stackCounter <`)
					snapPackageToCollider();
				}
			}else{
				console.log(`freeDropObject`)
				freeDropObject()
			}
		}

		function checkCanStackObject(){
			let underStackObject = null;
			let isOnTop = false;
			for (const obj of objects) {
				if (obj !== selectedPackage && obj.userData.type === 'parcel') {
					const packageHeightBot = selectedPackage.position.y-getPackageHeight(selectedPackage)/2;
					const objHeightTop = getPackageHeight(obj)/2 + obj.position.y;

					if (packageHeightBot == objHeightTop){
						if (!isOnTop){
							isOnTop = true;
						};
						const packageHalfWidth = getPackageWidth(selectedPackage) / 2;
						const packageHalfLength = selectedPackage.geometry.parameters.depth / 2;

						const colliderHalfWidth = getPackageWidth(obj) / 2;
						const colliderHalfLength = obj.geometry.parameters.depth / 2;

						const packageMinX = selectedPackage.position.x - packageHalfWidth;
						const packageMaxX = selectedPackage.position.x + packageHalfWidth;
						const packageMinZ = selectedPackage.position.z - packageHalfLength;
						const packageMaxZ = selectedPackage.position.z + packageHalfLength;

						const colliderMinX = obj.position.x - colliderHalfWidth;
						const colliderMaxX = obj.position.x + colliderHalfWidth;
						const colliderMinZ = obj.position.z - colliderHalfLength;
						const colliderMaxZ = obj.position.z + colliderHalfLength;
						if (colliderMinX <= packageMinX && colliderMaxX >= packageMaxX && colliderMinZ <= packageMinZ && colliderMaxZ >= packageMaxZ){
							underStackObject = obj;
						}
					}
				}
			}
			if (underStackObject != null){ 
				if (checkPackageHeavierThanPackage(selectedPackage,collidingObject)){
					showNotification('weightNotification',2000);
					return false;
				}else if (underStackObject.userData.packageData.canStack){
					return true;
				}else{
					showNotification('notification',2000);
					return false;
				}
			}else if (isOnTop){
				showNotification('scaleNotification',2000);
				return false;
			}else{
				showNotification('notificationInvalidPlace',2000);
				return false;
			}
		}

		function isBoxInsideWarehouse(newBox = selectedPackage) {
			if(!newBox){
				return false;
			}
			const boxHalfWidth = getPackageWidth(newBox) / 2;
			const boxHalfLength = newBox.geometry.parameters.depth / 2;

			const minX = newBox.position.x - boxHalfWidth;
			const maxX = newBox.position.x + boxHalfWidth;
			const minZ = newBox.position.z - boxHalfLength;
			const maxZ = newBox.position.z + boxHalfLength;
			const packageHeight = getPackageHeight(newBox)/2 + newBox.position.y

			const warehouseMinX = -warehouseDimensions.width / 2;
			const warehouseMaxX = warehouseDimensions.width / 2;
			const warehouseMinZ = -warehouseDimensions.length / 2;
			const warehouseMaxZ = warehouseDimensions.length / 2;
			const wareHouseHeight = warehouseDimensions.height;

			const isInside =
				minX >= warehouseMinX &&
				maxX <= warehouseMaxX &&
				minZ >= warehouseMinZ &&
				maxZ <= warehouseMaxZ &&
				packageHeight <= wareHouseHeight;

			return isInside;
		}

		function checkPackageHeavierThanPackage(package1,package2){
			if (package1 && package2){
				return package1.userData.packageData.weight > package2.userData.packageData.weight;
			}else{
				return false;
			}
		}

		function showNotification(notificationName, notificationDuration = 2000){
			const notification = document.getElementById(notificationName);
			notification.style.display = 'block';  
			setTimeout(() => {
				notification.style.display = 'none';
				isInEditor = true
			}, notificationDuration);
		}

		function freeDropObject(){
			stickToCursor = false;
			confirmDropObject();
		}

		function stackObjectOnTop(){
			stickToCursor = false;
			confirmDropObject();
		}

		function snapPackageToCollider() {			
			stickToCursor = false;
			confirmDropObject();
		}

		function confirmDropObject(){
			if(confirmSafePlace()){
				if(isBoxInsideWarehouse()){
					document.getElementById("warningMessage").style.display = "none";  // Hide warning message
					hideEdges();
				}else{
					changeEdgeColor(redColor);
				}
				clearSelectedObjectData();
			}else{
				stickToCursor = true
				showNotification('notificationInvalidPlace',2000)
			}
		}

		function confirmSafePlace(){
			if(selectedPackage){
				const selectedPackageOriginalCollision = new THREE.Box3().setFromObject(selectedPackage);
				const selectedPackageCollision =  new THREE.Box3(
					selectedPackageOriginalCollision.min.clone().addScalar(1),
					selectedPackageOriginalCollision.max.clone().addScalar(-1)
				);
				let existingCollisions = 0
				for(const obj of objects){
					const objCollision = new THREE.Box3().setFromObject(obj);
					if(selectedPackageCollision.intersectsBox(objCollision)){
						if (existingCollisions == 0){
							existingCollisions = 1
						}else{
							return false
						}
					}
				}
				return true;
			}else{
				return true;
			}
		}

		function checkCollisions(pkg){
			if(pkg){
				const selectedPackageOriginalCollision = new THREE.Box3().setFromObject(pkg);
				const selectedPackageCollision =  new THREE.Box3(
					selectedPackageOriginalCollision.min.clone().addScalar(-1),
					selectedPackageOriginalCollision.max.clone().addScalar(1)
				);
				let existingCollisions = 0
				for(const obj of objects){
					const objOriginalCollision = new THREE.Box3().setFromObject(obj);
					const objCollision =  new THREE.Box3(
						objOriginalCollision.min.clone().addScalar(-1),
						objOriginalCollision.max.clone().addScalar(1)
					);
					if(selectedPackageCollision.intersectsBox(objCollision)){
						if (existingCollisions == 0){
							existingCollisions = 1
						}else{
							return true
						}
					}
				}
				return false;
			}else{
				return false;
			}
		}

		function clearSelectedObjectData(){
			isColliding = false;
			collidingObject = null;
			selectedPackage = null;
		}

		function pickObject(xPos,zPos,yPos){
			hideEdges()
			if (isInEditor){
				clearSelectedObjectData()
				const intersects = raycaster.intersectObjects(objects, false);
				if (intersects.length > 0 && intersects[0].object.userData.type === 'parcel') {
					selectedPackage = intersects[0].object;
					if(hasPackageOnTop(selectedPackage)){
						clearSelectedObjectData()
						stickToCursor = false
						const notification = document.getElementById('stackedNotification');
						notification.style.display = 'block';  
						setTimeout(() => {
							notification.style.display = 'none';  // Hide after 2 seconds
							isInEditor = true
						}, 2000);
					}else{
						addEdgesToPackage()
						clearStickyRefs()
						/** Set on outlines here **/
						stickToCursor = true;
						selectedPackage.position.x = xPos;
						selectedPackage.position.z = zPos;
						selectedPackage.position.y = selectedPackage.geometry.parameters.height/2
					}
				}
			}
		}

		function hasPackageOnTop(targetPackage){
			if (targetPackage){
				for (const obj of objects) {
					if (obj !== targetPackage && obj.userData.type === 'parcel') {
						const packageHeightTop = targetPackage.position.y+getPackageHeight(targetPackage)/2;
						const objHeightBot = obj.position.y-getPackageHeight(obj)/2;

						if (objHeightBot == packageHeightTop){
							const packageHalfWidth = getPackageWidth(targetPackage) / 2;
							const packageHalfLength = targetPackage.geometry.parameters.depth / 2;

							const colliderHalfWidth = getPackageWidth(obj) / 2;
							const colliderHalfLength = obj.geometry.parameters.depth / 2;

							const packageMinX = targetPackage.position.x - packageHalfWidth;
							const packageMaxX = targetPackage.position.x + packageHalfWidth;
							const packageMinZ = targetPackage.position.z - packageHalfLength;
							const packageMaxZ = targetPackage.position.z + packageHalfLength;

							const colliderMinX = obj.position.x - colliderHalfWidth;
							const colliderMaxX = obj.position.x + colliderHalfWidth;
							const colliderMinZ = obj.position.z - colliderHalfLength;
							const colliderMaxZ = obj.position.z + colliderHalfLength;
							if (colliderMinX <= packageMinX && colliderMaxX >= packageMaxX && colliderMinZ <= packageMinZ && colliderMaxZ >= packageMaxZ){
								return true
								break;
							}
						}
					}
				}
			}
			return false
		}

		function clearStickyRefs(){
			/**To be removed**/
		}

		function addEdgesToPackage(edgedPackage=selectedPackage) {
			if(edgedPackage){
				if (!edgedPackage.geometry) {
					return;
				}
				for (let i = edgedPackage.children.length - 1; i >= 0; i--) {
					const child = edgedPackage.children[i];
					if (child instanceof THREE.LineSegments) {
						return;
					}
				}
				// Create edges geometry from the selectedPackage's geometry
				const edgesGeometry = new THREE.EdgesGeometry(edgedPackage.geometry);
				// Create a material with white color
				const edgesMaterial = new THREE.LineBasicMaterial({ color: 0xFFFFFF });
				// Create the edges as LineSegments
				const edges = new THREE.LineSegments(edgesGeometry, edgesMaterial);
				// Add the edges to the scene
				edgedPackage.add(edges);
				// Return the edges for further manipulation if needed
				return edges;
			}
		}

		function hideEdges(edgedPackage=selectedPackage){
			if(edgedPackage){
				for (let i = edgedPackage.children.length - 1; i >= 0; i--) {
					const child = edgedPackage.children[i];
					if (child instanceof THREE.LineSegments) {
						edgedPackage.remove(child);
					}
				}
			}
		}

		function changeEdgeColor(color,edgedPackage=selectedPackage) {
			if(edgedPackage){
				for (const child of edgedPackage.children) {
					// Check if the child is a LineSegments (edges)
					if (child instanceof THREE.LineSegments) {
						// Change the color of the material
						child.material.color.set(color);
					}
				}
			}
		}

		function EditObject(){
			if (isInEditor){
				const intersects = raycaster.intersectObjects(objects, false);
				if (intersects.length > 0 && intersects[0].object.userData.type === 'parcel') {
					rightClickedObject = intersects[0].object
				}
			}else{
				rightClickedObject = null
			}
		}

		function onDocumentKeyDown(event) {
			if (event.key === "Shift") {
				isShiftDown = true;
			}
		}

		function onDocumentKeyUp(event) {
			if (event.key === "Shift") {
				isShiftDown = false;
			}
		}

		function rotateParcel() {
			function toggleRotation(target) {
				if (checkCollisions(target)) {
					showNotification("collidingObjectNotification");
				} else {
					if (rotationDirection == rotationDirections.Horizental){
						rotateHorizentally(target);
					}else{
						rotateVertically(target);
					};
				}
			}

			if (rightClickedObject) {
				toggleRotation(rightClickedObject);
			} else if (selectedPackage) {
				toggleRotation(selectedPackage);
			}
		}

		function rotateVertically(target){
			const prevWidth = target.geometry.parameters.width;
			const prevHeight = target.geometry.parameters.height;
			const prevLength = target.geometry.parameters.depth;

			const yPosDiff = prevHeight - prevLength;

			target.geometry = new THREE.BoxGeometry(prevWidth, prevLength, prevHeight);

			target.position.y -= yPosDiff / 2;

			render();
		}

		function rotateHorizentally(target){
			const prevWidth = target.geometry.parameters.width;
			const prevHeight = target.geometry.parameters.height;
			const prevLength = target.geometry.parameters.depth;

			const yPosDiff = prevHeight-prevWidth

			target.geometry = new THREE.BoxGeometry(prevHeight, prevWidth, prevLength);
			target.position.y -= yPosDiff/2

			render();
		}

		function copyParcel() {
			if(rightClickedObject && rightClickedObject.userData.type === 'parcel'){
				copyParcelByPackage(rightClickedObject);
				updateBoxList();
			}
			else if (selectedPackage && selectedPackage.userData.type === 'parcel') {
				copyParcelByPackage(selectedPackage);
				updateBoxList();
			}
		}

		function deleteParcel() {
			if(rightClickedObject.userData.type === 'parcel'){
				if (hasPackageOnTop(rightClickedObject)){
					showNotification("collidingObjectNotification")
					return ;
				}
				const index = objects.indexOf(rightClickedObject);
				if (index !== -1) {
					deleteParcelByIndex(index);
					updateBoxList();
				}
			}
			else if (selectedPackage.userData.type === 'parcel') {
				if (hasPackageOnTop(selectedPackage)){
					showNotification("collidingObjectNotification")
					return ;
				}
				const index = objects.indexOf(selectedPackage);
				if (index !== -1) {
					deleteParcelByIndex(index);
					updateBoxList();
				}
			}
		}

		function updateBoxList() {
			const boxList = document.getElementById("boxListItems");
			boxList.innerHTML = "";  // Clear the current list

			objects.forEach((obj, index) => {
				if (obj.userData && obj.userData.packageData) {
					const packageData = obj.userData.packageData;

					const li = document.createElement("li");

					li.innerHTML = `
				<div class="package-header">
					<strong>${packageData.name}</strong>
					<div class="action-icons">
						<button class="edit-btn" data-index="${index}">Edit</button>
						<button class="copy-btn" data-index="${index}">Copy</button>
						<button class="delete-btn" data-index="${index}">Delete</button>
					</div>
				</div>
				<div class="package-details">
					<div class="detail-row">
						<p><strong>Width:</strong> ${packageData.width}</p>
						<p><strong>Height:</strong> ${packageData.height}</p>
						<p><strong>Length:</strong> ${packageData.length}</p>	
					</div>
					<div class="detail-row">
						<p><strong>Weight:</strong> ${packageData.weight}kg</p>
						<p><strong>Color:</strong> ${packageData.color}</p>

					</div>
					<div class="detail-row">
						<p><strong>Note:</strong> ${packageData.note}</p>
						<p><strong>Can Stack:</strong> ${packageData.canStack ? 'Yes' : 'No'}</p>
					</div>
				</div>
						`;

					boxList.appendChild(li);
				}
			});

			document.querySelectorAll("#boxListItems .edit-btn").forEach(button => {
				button.addEventListener("click", (event) => {
					const index = event.target.dataset.index;
					editPackage(index);  // Pass the selected package to edit function
				});
			});

			document.querySelectorAll("#boxListItems .copy-btn").forEach(button => {
				button.addEventListener("click", (event) => {
					const index = event.target.dataset.index;
					const selectedPackage = objects[index];
					copyParcelByPackage(selectedPackage);  // Pass the selected package to copy function
				});
			});

			document.querySelectorAll("#boxListItems .delete-btn").forEach(button => {
				button.addEventListener("click", (event) => {
					const index = event.target.dataset.index;
					deleteParcelByIndex(index);  // Pass the selected package to delete function
				});
			});
		}

		function copyParcelByPackage(mPackage) {

			const packageData = mPackage.userData.packageData;

			if (!packageData) {
				return;
			}

			const clonePackage = { ...packageData };

			const packageMesh = new THREE.Mesh(
				new THREE.BoxGeometry(clonePackage.width, clonePackage.height, clonePackage.length),
				new THREE.MeshLambertMaterial({ color: new THREE.Color(clonePackage.color) })
			);

			packageMesh.userData = {
				type: 'parcel',
				packageData: clonePackage
			};

			let isValidPosition = false;
			let attempts = 0;
			let maxAttempts = 1000;
			let newX = startPositions.x;
			let newZ = startPositions.z + clonePackage.length/2;

			while (!isValidPosition && attempts < maxAttempts) {
				newX = newX + clonePackage.width/2;
				if ((warehouseDimensions.width/2)<=newX){
					newX = startPositions.x  + clonePackage.width/2
					newZ = newZ + clonePackage.length/2;
				}
				if ((warehouseDimensions.length/2)<=newZ){
					isValidPosition = false;
					attempts = maxAttempts;
					break;
				}

				packageMesh.position.set(newX, getPackageHeight(packageMesh)/2, newZ);

				// Check for collisions with other objects
				isValidPosition = true;
				for (const obj of objects) {
					if (obj !== packageMesh && obj.userData.type === 'parcel') {
						const collisionResult = checkCollision(packageMesh, obj,-1);
						if (collisionResult.marginCollision) {
							isValidPosition = false;
							break;
						}
					}
				}
				attempts++;
			}

			if (!isValidPosition) {
				alert("Could not find a valid position for the package in the warehouse.");
				packageMesh.geometry.dispose();
				packageMesh.material.dispose();
				return;
			}
				
			scene.add(packageMesh);
			objects.push(packageMesh);
			packages.push(clonePackage);
			if (!isBoxInsideWarehouse(packageMesh)) {
				hideEdges(packageMesh)
				addEdgesToPackage(packageMesh)
				changeEdgeColor(redColor,packageMesh)
				document.getElementById("warningMessage").style.display = "block";  // Show warning message
			} else {
				hideEdges(packageMesh)
				document.getElementById("warningMessage").style.display = "none";  // Hide warning message
			}

			updateBoxList();
			calculateTotalWeight();
			if (totalWeight>warehouseDimensions.weightLimit){
				showNotification("weightLimitNotification");
			};
			render();
		}

		function deleteParcelByIndex(index) {
			const packageMesh = objects[index];

			scene.remove(packageMesh);

			packageMesh.geometry.dispose();
			packageMesh.material.dispose();

			objects.splice(index, 1);
			packages.splice(index, 1);

			updateBoxList();

			calculateTotalWeight();
			render();
		}


		function onWindowResize() {
			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();
			renderer.setSize(window.innerWidth, window.innerHeight);
		}

		function render() {
			cameraControls.update();
			renderer.render(scene, camera);
		}

	</script>
</body>
</html>